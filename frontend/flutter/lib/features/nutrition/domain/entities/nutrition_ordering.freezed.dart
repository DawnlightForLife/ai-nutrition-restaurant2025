// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'nutrition_ordering.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

NutritionElement _$NutritionElementFromJson(Map<String, dynamic> json) {
  return _NutritionElement.fromJson(json);
}

/// @nodoc
mixin _$NutritionElement {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get chineseName => throw _privateConstructorUsedError;
  String? get scientificName => throw _privateConstructorUsedError;
  List<String> get aliases => throw _privateConstructorUsedError;
  String get category => throw _privateConstructorUsedError;
  String? get subCategory => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  String get importance => throw _privateConstructorUsedError;
  List<String> get functions => throw _privateConstructorUsedError;
  List<String> get healthBenefits => throw _privateConstructorUsedError;
  List<String> get deficiencySymptoms => throw _privateConstructorUsedError;
  List<String> get overdoseRisks => throw _privateConstructorUsedError;
  Map<String, dynamic>? get recommendedIntake =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get specialConditionNeeds =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get absorption => throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get foodSources =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get cookingEffects =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get interactions => throw _privateConstructorUsedError;
  bool? get isActive => throw _privateConstructorUsedError;
  DateTime? get lastUpdated => throw _privateConstructorUsedError;
  int get version => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionElement value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionElement value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionElement value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionElement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionElementCopyWith<NutritionElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionElementCopyWith<$Res> {
  factory $NutritionElementCopyWith(
          NutritionElement value, $Res Function(NutritionElement) then) =
      _$NutritionElementCopyWithImpl<$Res, NutritionElement>;
  @useResult
  $Res call(
      {String id,
      String name,
      String chineseName,
      String? scientificName,
      List<String> aliases,
      String category,
      String? subCategory,
      String unit,
      String importance,
      List<String> functions,
      List<String> healthBenefits,
      List<String> deficiencySymptoms,
      List<String> overdoseRisks,
      Map<String, dynamic>? recommendedIntake,
      Map<String, dynamic>? specialConditionNeeds,
      Map<String, dynamic>? absorption,
      List<Map<String, dynamic>> foodSources,
      Map<String, dynamic>? cookingEffects,
      Map<String, dynamic>? interactions,
      bool? isActive,
      DateTime? lastUpdated,
      int version});
}

/// @nodoc
class _$NutritionElementCopyWithImpl<$Res, $Val extends NutritionElement>
    implements $NutritionElementCopyWith<$Res> {
  _$NutritionElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? chineseName = null,
    Object? scientificName = freezed,
    Object? aliases = null,
    Object? category = null,
    Object? subCategory = freezed,
    Object? unit = null,
    Object? importance = null,
    Object? functions = null,
    Object? healthBenefits = null,
    Object? deficiencySymptoms = null,
    Object? overdoseRisks = null,
    Object? recommendedIntake = freezed,
    Object? specialConditionNeeds = freezed,
    Object? absorption = freezed,
    Object? foodSources = null,
    Object? cookingEffects = freezed,
    Object? interactions = freezed,
    Object? isActive = freezed,
    Object? lastUpdated = freezed,
    Object? version = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chineseName: null == chineseName
          ? _value.chineseName
          : chineseName // ignore: cast_nullable_to_non_nullable
              as String,
      scientificName: freezed == scientificName
          ? _value.scientificName
          : scientificName // ignore: cast_nullable_to_non_nullable
              as String?,
      aliases: null == aliases
          ? _value.aliases
          : aliases // ignore: cast_nullable_to_non_nullable
              as List<String>,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      subCategory: freezed == subCategory
          ? _value.subCategory
          : subCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      importance: null == importance
          ? _value.importance
          : importance // ignore: cast_nullable_to_non_nullable
              as String,
      functions: null == functions
          ? _value.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<String>,
      healthBenefits: null == healthBenefits
          ? _value.healthBenefits
          : healthBenefits // ignore: cast_nullable_to_non_nullable
              as List<String>,
      deficiencySymptoms: null == deficiencySymptoms
          ? _value.deficiencySymptoms
          : deficiencySymptoms // ignore: cast_nullable_to_non_nullable
              as List<String>,
      overdoseRisks: null == overdoseRisks
          ? _value.overdoseRisks
          : overdoseRisks // ignore: cast_nullable_to_non_nullable
              as List<String>,
      recommendedIntake: freezed == recommendedIntake
          ? _value.recommendedIntake
          : recommendedIntake // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      specialConditionNeeds: freezed == specialConditionNeeds
          ? _value.specialConditionNeeds
          : specialConditionNeeds // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      absorption: freezed == absorption
          ? _value.absorption
          : absorption // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      foodSources: null == foodSources
          ? _value.foodSources
          : foodSources // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      cookingEffects: freezed == cookingEffects
          ? _value.cookingEffects
          : cookingEffects // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      interactions: freezed == interactions
          ? _value.interactions
          : interactions // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      lastUpdated: freezed == lastUpdated
          ? _value.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionElementImplCopyWith<$Res>
    implements $NutritionElementCopyWith<$Res> {
  factory _$$NutritionElementImplCopyWith(_$NutritionElementImpl value,
          $Res Function(_$NutritionElementImpl) then) =
      __$$NutritionElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String chineseName,
      String? scientificName,
      List<String> aliases,
      String category,
      String? subCategory,
      String unit,
      String importance,
      List<String> functions,
      List<String> healthBenefits,
      List<String> deficiencySymptoms,
      List<String> overdoseRisks,
      Map<String, dynamic>? recommendedIntake,
      Map<String, dynamic>? specialConditionNeeds,
      Map<String, dynamic>? absorption,
      List<Map<String, dynamic>> foodSources,
      Map<String, dynamic>? cookingEffects,
      Map<String, dynamic>? interactions,
      bool? isActive,
      DateTime? lastUpdated,
      int version});
}

/// @nodoc
class __$$NutritionElementImplCopyWithImpl<$Res>
    extends _$NutritionElementCopyWithImpl<$Res, _$NutritionElementImpl>
    implements _$$NutritionElementImplCopyWith<$Res> {
  __$$NutritionElementImplCopyWithImpl(_$NutritionElementImpl _value,
      $Res Function(_$NutritionElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? chineseName = null,
    Object? scientificName = freezed,
    Object? aliases = null,
    Object? category = null,
    Object? subCategory = freezed,
    Object? unit = null,
    Object? importance = null,
    Object? functions = null,
    Object? healthBenefits = null,
    Object? deficiencySymptoms = null,
    Object? overdoseRisks = null,
    Object? recommendedIntake = freezed,
    Object? specialConditionNeeds = freezed,
    Object? absorption = freezed,
    Object? foodSources = null,
    Object? cookingEffects = freezed,
    Object? interactions = freezed,
    Object? isActive = freezed,
    Object? lastUpdated = freezed,
    Object? version = null,
  }) {
    return _then(_$NutritionElementImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chineseName: null == chineseName
          ? _value.chineseName
          : chineseName // ignore: cast_nullable_to_non_nullable
              as String,
      scientificName: freezed == scientificName
          ? _value.scientificName
          : scientificName // ignore: cast_nullable_to_non_nullable
              as String?,
      aliases: null == aliases
          ? _value._aliases
          : aliases // ignore: cast_nullable_to_non_nullable
              as List<String>,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      subCategory: freezed == subCategory
          ? _value.subCategory
          : subCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      importance: null == importance
          ? _value.importance
          : importance // ignore: cast_nullable_to_non_nullable
              as String,
      functions: null == functions
          ? _value._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<String>,
      healthBenefits: null == healthBenefits
          ? _value._healthBenefits
          : healthBenefits // ignore: cast_nullable_to_non_nullable
              as List<String>,
      deficiencySymptoms: null == deficiencySymptoms
          ? _value._deficiencySymptoms
          : deficiencySymptoms // ignore: cast_nullable_to_non_nullable
              as List<String>,
      overdoseRisks: null == overdoseRisks
          ? _value._overdoseRisks
          : overdoseRisks // ignore: cast_nullable_to_non_nullable
              as List<String>,
      recommendedIntake: freezed == recommendedIntake
          ? _value._recommendedIntake
          : recommendedIntake // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      specialConditionNeeds: freezed == specialConditionNeeds
          ? _value._specialConditionNeeds
          : specialConditionNeeds // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      absorption: freezed == absorption
          ? _value._absorption
          : absorption // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      foodSources: null == foodSources
          ? _value._foodSources
          : foodSources // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      cookingEffects: freezed == cookingEffects
          ? _value._cookingEffects
          : cookingEffects // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      interactions: freezed == interactions
          ? _value._interactions
          : interactions // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      lastUpdated: freezed == lastUpdated
          ? _value.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionElementImpl implements _NutritionElement {
  const _$NutritionElementImpl(
      {required this.id,
      required this.name,
      required this.chineseName,
      this.scientificName,
      final List<String> aliases = const [],
      required this.category,
      this.subCategory,
      required this.unit,
      this.importance = 'beneficial',
      final List<String> functions = const [],
      final List<String> healthBenefits = const [],
      final List<String> deficiencySymptoms = const [],
      final List<String> overdoseRisks = const [],
      final Map<String, dynamic>? recommendedIntake,
      final Map<String, dynamic>? specialConditionNeeds,
      final Map<String, dynamic>? absorption,
      final List<Map<String, dynamic>> foodSources = const [],
      final Map<String, dynamic>? cookingEffects,
      final Map<String, dynamic>? interactions,
      this.isActive,
      this.lastUpdated,
      this.version = 1})
      : _aliases = aliases,
        _functions = functions,
        _healthBenefits = healthBenefits,
        _deficiencySymptoms = deficiencySymptoms,
        _overdoseRisks = overdoseRisks,
        _recommendedIntake = recommendedIntake,
        _specialConditionNeeds = specialConditionNeeds,
        _absorption = absorption,
        _foodSources = foodSources,
        _cookingEffects = cookingEffects,
        _interactions = interactions;

  factory _$NutritionElementImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionElementImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String chineseName;
  @override
  final String? scientificName;
  final List<String> _aliases;
  @override
  @JsonKey()
  List<String> get aliases {
    if (_aliases is EqualUnmodifiableListView) return _aliases;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_aliases);
  }

  @override
  final String category;
  @override
  final String? subCategory;
  @override
  final String unit;
  @override
  @JsonKey()
  final String importance;
  final List<String> _functions;
  @override
  @JsonKey()
  List<String> get functions {
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_functions);
  }

  final List<String> _healthBenefits;
  @override
  @JsonKey()
  List<String> get healthBenefits {
    if (_healthBenefits is EqualUnmodifiableListView) return _healthBenefits;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_healthBenefits);
  }

  final List<String> _deficiencySymptoms;
  @override
  @JsonKey()
  List<String> get deficiencySymptoms {
    if (_deficiencySymptoms is EqualUnmodifiableListView)
      return _deficiencySymptoms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deficiencySymptoms);
  }

  final List<String> _overdoseRisks;
  @override
  @JsonKey()
  List<String> get overdoseRisks {
    if (_overdoseRisks is EqualUnmodifiableListView) return _overdoseRisks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_overdoseRisks);
  }

  final Map<String, dynamic>? _recommendedIntake;
  @override
  Map<String, dynamic>? get recommendedIntake {
    final value = _recommendedIntake;
    if (value == null) return null;
    if (_recommendedIntake is EqualUnmodifiableMapView)
      return _recommendedIntake;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _specialConditionNeeds;
  @override
  Map<String, dynamic>? get specialConditionNeeds {
    final value = _specialConditionNeeds;
    if (value == null) return null;
    if (_specialConditionNeeds is EqualUnmodifiableMapView)
      return _specialConditionNeeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _absorption;
  @override
  Map<String, dynamic>? get absorption {
    final value = _absorption;
    if (value == null) return null;
    if (_absorption is EqualUnmodifiableMapView) return _absorption;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<Map<String, dynamic>> _foodSources;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get foodSources {
    if (_foodSources is EqualUnmodifiableListView) return _foodSources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_foodSources);
  }

  final Map<String, dynamic>? _cookingEffects;
  @override
  Map<String, dynamic>? get cookingEffects {
    final value = _cookingEffects;
    if (value == null) return null;
    if (_cookingEffects is EqualUnmodifiableMapView) return _cookingEffects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _interactions;
  @override
  Map<String, dynamic>? get interactions {
    final value = _interactions;
    if (value == null) return null;
    if (_interactions is EqualUnmodifiableMapView) return _interactions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final bool? isActive;
  @override
  final DateTime? lastUpdated;
  @override
  @JsonKey()
  final int version;

  @override
  String toString() {
    return 'NutritionElement(id: $id, name: $name, chineseName: $chineseName, scientificName: $scientificName, aliases: $aliases, category: $category, subCategory: $subCategory, unit: $unit, importance: $importance, functions: $functions, healthBenefits: $healthBenefits, deficiencySymptoms: $deficiencySymptoms, overdoseRisks: $overdoseRisks, recommendedIntake: $recommendedIntake, specialConditionNeeds: $specialConditionNeeds, absorption: $absorption, foodSources: $foodSources, cookingEffects: $cookingEffects, interactions: $interactions, isActive: $isActive, lastUpdated: $lastUpdated, version: $version)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionElementImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.chineseName, chineseName) ||
                other.chineseName == chineseName) &&
            (identical(other.scientificName, scientificName) ||
                other.scientificName == scientificName) &&
            const DeepCollectionEquality().equals(other._aliases, _aliases) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.subCategory, subCategory) ||
                other.subCategory == subCategory) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.importance, importance) ||
                other.importance == importance) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions) &&
            const DeepCollectionEquality()
                .equals(other._healthBenefits, _healthBenefits) &&
            const DeepCollectionEquality()
                .equals(other._deficiencySymptoms, _deficiencySymptoms) &&
            const DeepCollectionEquality()
                .equals(other._overdoseRisks, _overdoseRisks) &&
            const DeepCollectionEquality()
                .equals(other._recommendedIntake, _recommendedIntake) &&
            const DeepCollectionEquality()
                .equals(other._specialConditionNeeds, _specialConditionNeeds) &&
            const DeepCollectionEquality()
                .equals(other._absorption, _absorption) &&
            const DeepCollectionEquality()
                .equals(other._foodSources, _foodSources) &&
            const DeepCollectionEquality()
                .equals(other._cookingEffects, _cookingEffects) &&
            const DeepCollectionEquality()
                .equals(other._interactions, _interactions) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.version, version) || other.version == version));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        chineseName,
        scientificName,
        const DeepCollectionEquality().hash(_aliases),
        category,
        subCategory,
        unit,
        importance,
        const DeepCollectionEquality().hash(_functions),
        const DeepCollectionEquality().hash(_healthBenefits),
        const DeepCollectionEquality().hash(_deficiencySymptoms),
        const DeepCollectionEquality().hash(_overdoseRisks),
        const DeepCollectionEquality().hash(_recommendedIntake),
        const DeepCollectionEquality().hash(_specialConditionNeeds),
        const DeepCollectionEquality().hash(_absorption),
        const DeepCollectionEquality().hash(_foodSources),
        const DeepCollectionEquality().hash(_cookingEffects),
        const DeepCollectionEquality().hash(_interactions),
        isActive,
        lastUpdated,
        version
      ]);

  /// Create a copy of NutritionElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionElementImplCopyWith<_$NutritionElementImpl> get copyWith =>
      __$$NutritionElementImplCopyWithImpl<_$NutritionElementImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionElement value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionElement value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionElement value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionElementImplToJson(
      this,
    );
  }
}

abstract class _NutritionElement implements NutritionElement {
  const factory _NutritionElement(
      {required final String id,
      required final String name,
      required final String chineseName,
      final String? scientificName,
      final List<String> aliases,
      required final String category,
      final String? subCategory,
      required final String unit,
      final String importance,
      final List<String> functions,
      final List<String> healthBenefits,
      final List<String> deficiencySymptoms,
      final List<String> overdoseRisks,
      final Map<String, dynamic>? recommendedIntake,
      final Map<String, dynamic>? specialConditionNeeds,
      final Map<String, dynamic>? absorption,
      final List<Map<String, dynamic>> foodSources,
      final Map<String, dynamic>? cookingEffects,
      final Map<String, dynamic>? interactions,
      final bool? isActive,
      final DateTime? lastUpdated,
      final int version}) = _$NutritionElementImpl;

  factory _NutritionElement.fromJson(Map<String, dynamic> json) =
      _$NutritionElementImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get chineseName;
  @override
  String? get scientificName;
  @override
  List<String> get aliases;
  @override
  String get category;
  @override
  String? get subCategory;
  @override
  String get unit;
  @override
  String get importance;
  @override
  List<String> get functions;
  @override
  List<String> get healthBenefits;
  @override
  List<String> get deficiencySymptoms;
  @override
  List<String> get overdoseRisks;
  @override
  Map<String, dynamic>? get recommendedIntake;
  @override
  Map<String, dynamic>? get specialConditionNeeds;
  @override
  Map<String, dynamic>? get absorption;
  @override
  List<Map<String, dynamic>> get foodSources;
  @override
  Map<String, dynamic>? get cookingEffects;
  @override
  Map<String, dynamic>? get interactions;
  @override
  bool? get isActive;
  @override
  DateTime? get lastUpdated;
  @override
  int get version;

  /// Create a copy of NutritionElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionElementImplCopyWith<_$NutritionElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientNutrition _$IngredientNutritionFromJson(Map<String, dynamic> json) {
  return _IngredientNutrition.fromJson(json);
}

/// @nodoc
mixin _$IngredientNutrition {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get chineseName => throw _privateConstructorUsedError;
  String? get scientificName => throw _privateConstructorUsedError;
  List<String> get commonNames => throw _privateConstructorUsedError;
  String get category => throw _privateConstructorUsedError;
  String? get subCategory => throw _privateConstructorUsedError;
  ServingSize get servingSize => throw _privateConstructorUsedError;
  Map<String, String>? get nutritionDensity =>
      throw _privateConstructorUsedError;
  List<NutritionContent> get nutritionContent =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get macronutrients =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get aminoAcidProfile =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get fattyAcidProfile =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get antinutrients =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get bioactiveCompounds =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get glycemicResponse =>
      throw _privateConstructorUsedError;
  String get freshnessLevel => throw _privateConstructorUsedError;
  Map<String, dynamic>? get seasonalVariation =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get storageConditions =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get originInfo => throw _privateConstructorUsedError;
  Map<String, dynamic>? get sustainabilityScore =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get allergenInfo => throw _privateConstructorUsedError;
  bool? get isActive => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_IngredientNutrition value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_IngredientNutrition value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_IngredientNutrition value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this IngredientNutrition to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IngredientNutrition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IngredientNutritionCopyWith<IngredientNutrition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientNutritionCopyWith<$Res> {
  factory $IngredientNutritionCopyWith(
          IngredientNutrition value, $Res Function(IngredientNutrition) then) =
      _$IngredientNutritionCopyWithImpl<$Res, IngredientNutrition>;
  @useResult
  $Res call(
      {String id,
      String name,
      String chineseName,
      String? scientificName,
      List<String> commonNames,
      String category,
      String? subCategory,
      ServingSize servingSize,
      Map<String, String>? nutritionDensity,
      List<NutritionContent> nutritionContent,
      Map<String, dynamic>? macronutrients,
      Map<String, dynamic>? aminoAcidProfile,
      List<Map<String, dynamic>> fattyAcidProfile,
      List<Map<String, dynamic>> antinutrients,
      List<Map<String, dynamic>> bioactiveCompounds,
      Map<String, dynamic>? glycemicResponse,
      String freshnessLevel,
      Map<String, dynamic>? seasonalVariation,
      Map<String, dynamic>? storageConditions,
      Map<String, dynamic>? originInfo,
      Map<String, dynamic>? sustainabilityScore,
      Map<String, dynamic>? allergenInfo,
      bool? isActive});

  $ServingSizeCopyWith<$Res> get servingSize;
}

/// @nodoc
class _$IngredientNutritionCopyWithImpl<$Res, $Val extends IngredientNutrition>
    implements $IngredientNutritionCopyWith<$Res> {
  _$IngredientNutritionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IngredientNutrition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? chineseName = null,
    Object? scientificName = freezed,
    Object? commonNames = null,
    Object? category = null,
    Object? subCategory = freezed,
    Object? servingSize = null,
    Object? nutritionDensity = freezed,
    Object? nutritionContent = null,
    Object? macronutrients = freezed,
    Object? aminoAcidProfile = freezed,
    Object? fattyAcidProfile = null,
    Object? antinutrients = null,
    Object? bioactiveCompounds = null,
    Object? glycemicResponse = freezed,
    Object? freshnessLevel = null,
    Object? seasonalVariation = freezed,
    Object? storageConditions = freezed,
    Object? originInfo = freezed,
    Object? sustainabilityScore = freezed,
    Object? allergenInfo = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chineseName: null == chineseName
          ? _value.chineseName
          : chineseName // ignore: cast_nullable_to_non_nullable
              as String,
      scientificName: freezed == scientificName
          ? _value.scientificName
          : scientificName // ignore: cast_nullable_to_non_nullable
              as String?,
      commonNames: null == commonNames
          ? _value.commonNames
          : commonNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      subCategory: freezed == subCategory
          ? _value.subCategory
          : subCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      servingSize: null == servingSize
          ? _value.servingSize
          : servingSize // ignore: cast_nullable_to_non_nullable
              as ServingSize,
      nutritionDensity: freezed == nutritionDensity
          ? _value.nutritionDensity
          : nutritionDensity // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      nutritionContent: null == nutritionContent
          ? _value.nutritionContent
          : nutritionContent // ignore: cast_nullable_to_non_nullable
              as List<NutritionContent>,
      macronutrients: freezed == macronutrients
          ? _value.macronutrients
          : macronutrients // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      aminoAcidProfile: freezed == aminoAcidProfile
          ? _value.aminoAcidProfile
          : aminoAcidProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      fattyAcidProfile: null == fattyAcidProfile
          ? _value.fattyAcidProfile
          : fattyAcidProfile // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      antinutrients: null == antinutrients
          ? _value.antinutrients
          : antinutrients // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      bioactiveCompounds: null == bioactiveCompounds
          ? _value.bioactiveCompounds
          : bioactiveCompounds // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      glycemicResponse: freezed == glycemicResponse
          ? _value.glycemicResponse
          : glycemicResponse // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      freshnessLevel: null == freshnessLevel
          ? _value.freshnessLevel
          : freshnessLevel // ignore: cast_nullable_to_non_nullable
              as String,
      seasonalVariation: freezed == seasonalVariation
          ? _value.seasonalVariation
          : seasonalVariation // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      storageConditions: freezed == storageConditions
          ? _value.storageConditions
          : storageConditions // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      originInfo: freezed == originInfo
          ? _value.originInfo
          : originInfo // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      sustainabilityScore: freezed == sustainabilityScore
          ? _value.sustainabilityScore
          : sustainabilityScore // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      allergenInfo: freezed == allergenInfo
          ? _value.allergenInfo
          : allergenInfo // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  /// Create a copy of IngredientNutrition
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ServingSizeCopyWith<$Res> get servingSize {
    return $ServingSizeCopyWith<$Res>(_value.servingSize, (value) {
      return _then(_value.copyWith(servingSize: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$IngredientNutritionImplCopyWith<$Res>
    implements $IngredientNutritionCopyWith<$Res> {
  factory _$$IngredientNutritionImplCopyWith(_$IngredientNutritionImpl value,
          $Res Function(_$IngredientNutritionImpl) then) =
      __$$IngredientNutritionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String chineseName,
      String? scientificName,
      List<String> commonNames,
      String category,
      String? subCategory,
      ServingSize servingSize,
      Map<String, String>? nutritionDensity,
      List<NutritionContent> nutritionContent,
      Map<String, dynamic>? macronutrients,
      Map<String, dynamic>? aminoAcidProfile,
      List<Map<String, dynamic>> fattyAcidProfile,
      List<Map<String, dynamic>> antinutrients,
      List<Map<String, dynamic>> bioactiveCompounds,
      Map<String, dynamic>? glycemicResponse,
      String freshnessLevel,
      Map<String, dynamic>? seasonalVariation,
      Map<String, dynamic>? storageConditions,
      Map<String, dynamic>? originInfo,
      Map<String, dynamic>? sustainabilityScore,
      Map<String, dynamic>? allergenInfo,
      bool? isActive});

  @override
  $ServingSizeCopyWith<$Res> get servingSize;
}

/// @nodoc
class __$$IngredientNutritionImplCopyWithImpl<$Res>
    extends _$IngredientNutritionCopyWithImpl<$Res, _$IngredientNutritionImpl>
    implements _$$IngredientNutritionImplCopyWith<$Res> {
  __$$IngredientNutritionImplCopyWithImpl(_$IngredientNutritionImpl _value,
      $Res Function(_$IngredientNutritionImpl) _then)
      : super(_value, _then);

  /// Create a copy of IngredientNutrition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? chineseName = null,
    Object? scientificName = freezed,
    Object? commonNames = null,
    Object? category = null,
    Object? subCategory = freezed,
    Object? servingSize = null,
    Object? nutritionDensity = freezed,
    Object? nutritionContent = null,
    Object? macronutrients = freezed,
    Object? aminoAcidProfile = freezed,
    Object? fattyAcidProfile = null,
    Object? antinutrients = null,
    Object? bioactiveCompounds = null,
    Object? glycemicResponse = freezed,
    Object? freshnessLevel = null,
    Object? seasonalVariation = freezed,
    Object? storageConditions = freezed,
    Object? originInfo = freezed,
    Object? sustainabilityScore = freezed,
    Object? allergenInfo = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_$IngredientNutritionImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chineseName: null == chineseName
          ? _value.chineseName
          : chineseName // ignore: cast_nullable_to_non_nullable
              as String,
      scientificName: freezed == scientificName
          ? _value.scientificName
          : scientificName // ignore: cast_nullable_to_non_nullable
              as String?,
      commonNames: null == commonNames
          ? _value._commonNames
          : commonNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      subCategory: freezed == subCategory
          ? _value.subCategory
          : subCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      servingSize: null == servingSize
          ? _value.servingSize
          : servingSize // ignore: cast_nullable_to_non_nullable
              as ServingSize,
      nutritionDensity: freezed == nutritionDensity
          ? _value._nutritionDensity
          : nutritionDensity // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      nutritionContent: null == nutritionContent
          ? _value._nutritionContent
          : nutritionContent // ignore: cast_nullable_to_non_nullable
              as List<NutritionContent>,
      macronutrients: freezed == macronutrients
          ? _value._macronutrients
          : macronutrients // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      aminoAcidProfile: freezed == aminoAcidProfile
          ? _value._aminoAcidProfile
          : aminoAcidProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      fattyAcidProfile: null == fattyAcidProfile
          ? _value._fattyAcidProfile
          : fattyAcidProfile // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      antinutrients: null == antinutrients
          ? _value._antinutrients
          : antinutrients // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      bioactiveCompounds: null == bioactiveCompounds
          ? _value._bioactiveCompounds
          : bioactiveCompounds // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      glycemicResponse: freezed == glycemicResponse
          ? _value._glycemicResponse
          : glycemicResponse // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      freshnessLevel: null == freshnessLevel
          ? _value.freshnessLevel
          : freshnessLevel // ignore: cast_nullable_to_non_nullable
              as String,
      seasonalVariation: freezed == seasonalVariation
          ? _value._seasonalVariation
          : seasonalVariation // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      storageConditions: freezed == storageConditions
          ? _value._storageConditions
          : storageConditions // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      originInfo: freezed == originInfo
          ? _value._originInfo
          : originInfo // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      sustainabilityScore: freezed == sustainabilityScore
          ? _value._sustainabilityScore
          : sustainabilityScore // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      allergenInfo: freezed == allergenInfo
          ? _value._allergenInfo
          : allergenInfo // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IngredientNutritionImpl implements _IngredientNutrition {
  const _$IngredientNutritionImpl(
      {required this.id,
      required this.name,
      required this.chineseName,
      this.scientificName,
      final List<String> commonNames = const [],
      required this.category,
      this.subCategory,
      required this.servingSize,
      final Map<String, String>? nutritionDensity,
      final List<NutritionContent> nutritionContent = const [],
      final Map<String, dynamic>? macronutrients,
      final Map<String, dynamic>? aminoAcidProfile,
      final List<Map<String, dynamic>> fattyAcidProfile = const [],
      final List<Map<String, dynamic>> antinutrients = const [],
      final List<Map<String, dynamic>> bioactiveCompounds = const [],
      final Map<String, dynamic>? glycemicResponse,
      this.freshnessLevel = 'fresh',
      final Map<String, dynamic>? seasonalVariation,
      final Map<String, dynamic>? storageConditions,
      final Map<String, dynamic>? originInfo,
      final Map<String, dynamic>? sustainabilityScore,
      final Map<String, dynamic>? allergenInfo,
      this.isActive})
      : _commonNames = commonNames,
        _nutritionDensity = nutritionDensity,
        _nutritionContent = nutritionContent,
        _macronutrients = macronutrients,
        _aminoAcidProfile = aminoAcidProfile,
        _fattyAcidProfile = fattyAcidProfile,
        _antinutrients = antinutrients,
        _bioactiveCompounds = bioactiveCompounds,
        _glycemicResponse = glycemicResponse,
        _seasonalVariation = seasonalVariation,
        _storageConditions = storageConditions,
        _originInfo = originInfo,
        _sustainabilityScore = sustainabilityScore,
        _allergenInfo = allergenInfo;

  factory _$IngredientNutritionImpl.fromJson(Map<String, dynamic> json) =>
      _$$IngredientNutritionImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String chineseName;
  @override
  final String? scientificName;
  final List<String> _commonNames;
  @override
  @JsonKey()
  List<String> get commonNames {
    if (_commonNames is EqualUnmodifiableListView) return _commonNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_commonNames);
  }

  @override
  final String category;
  @override
  final String? subCategory;
  @override
  final ServingSize servingSize;
  final Map<String, String>? _nutritionDensity;
  @override
  Map<String, String>? get nutritionDensity {
    final value = _nutritionDensity;
    if (value == null) return null;
    if (_nutritionDensity is EqualUnmodifiableMapView) return _nutritionDensity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<NutritionContent> _nutritionContent;
  @override
  @JsonKey()
  List<NutritionContent> get nutritionContent {
    if (_nutritionContent is EqualUnmodifiableListView)
      return _nutritionContent;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_nutritionContent);
  }

  final Map<String, dynamic>? _macronutrients;
  @override
  Map<String, dynamic>? get macronutrients {
    final value = _macronutrients;
    if (value == null) return null;
    if (_macronutrients is EqualUnmodifiableMapView) return _macronutrients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _aminoAcidProfile;
  @override
  Map<String, dynamic>? get aminoAcidProfile {
    final value = _aminoAcidProfile;
    if (value == null) return null;
    if (_aminoAcidProfile is EqualUnmodifiableMapView) return _aminoAcidProfile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<Map<String, dynamic>> _fattyAcidProfile;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get fattyAcidProfile {
    if (_fattyAcidProfile is EqualUnmodifiableListView)
      return _fattyAcidProfile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fattyAcidProfile);
  }

  final List<Map<String, dynamic>> _antinutrients;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get antinutrients {
    if (_antinutrients is EqualUnmodifiableListView) return _antinutrients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_antinutrients);
  }

  final List<Map<String, dynamic>> _bioactiveCompounds;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get bioactiveCompounds {
    if (_bioactiveCompounds is EqualUnmodifiableListView)
      return _bioactiveCompounds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bioactiveCompounds);
  }

  final Map<String, dynamic>? _glycemicResponse;
  @override
  Map<String, dynamic>? get glycemicResponse {
    final value = _glycemicResponse;
    if (value == null) return null;
    if (_glycemicResponse is EqualUnmodifiableMapView) return _glycemicResponse;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey()
  final String freshnessLevel;
  final Map<String, dynamic>? _seasonalVariation;
  @override
  Map<String, dynamic>? get seasonalVariation {
    final value = _seasonalVariation;
    if (value == null) return null;
    if (_seasonalVariation is EqualUnmodifiableMapView)
      return _seasonalVariation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _storageConditions;
  @override
  Map<String, dynamic>? get storageConditions {
    final value = _storageConditions;
    if (value == null) return null;
    if (_storageConditions is EqualUnmodifiableMapView)
      return _storageConditions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _originInfo;
  @override
  Map<String, dynamic>? get originInfo {
    final value = _originInfo;
    if (value == null) return null;
    if (_originInfo is EqualUnmodifiableMapView) return _originInfo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _sustainabilityScore;
  @override
  Map<String, dynamic>? get sustainabilityScore {
    final value = _sustainabilityScore;
    if (value == null) return null;
    if (_sustainabilityScore is EqualUnmodifiableMapView)
      return _sustainabilityScore;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _allergenInfo;
  @override
  Map<String, dynamic>? get allergenInfo {
    final value = _allergenInfo;
    if (value == null) return null;
    if (_allergenInfo is EqualUnmodifiableMapView) return _allergenInfo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final bool? isActive;

  @override
  String toString() {
    return 'IngredientNutrition(id: $id, name: $name, chineseName: $chineseName, scientificName: $scientificName, commonNames: $commonNames, category: $category, subCategory: $subCategory, servingSize: $servingSize, nutritionDensity: $nutritionDensity, nutritionContent: $nutritionContent, macronutrients: $macronutrients, aminoAcidProfile: $aminoAcidProfile, fattyAcidProfile: $fattyAcidProfile, antinutrients: $antinutrients, bioactiveCompounds: $bioactiveCompounds, glycemicResponse: $glycemicResponse, freshnessLevel: $freshnessLevel, seasonalVariation: $seasonalVariation, storageConditions: $storageConditions, originInfo: $originInfo, sustainabilityScore: $sustainabilityScore, allergenInfo: $allergenInfo, isActive: $isActive)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IngredientNutritionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.chineseName, chineseName) ||
                other.chineseName == chineseName) &&
            (identical(other.scientificName, scientificName) ||
                other.scientificName == scientificName) &&
            const DeepCollectionEquality()
                .equals(other._commonNames, _commonNames) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.subCategory, subCategory) ||
                other.subCategory == subCategory) &&
            (identical(other.servingSize, servingSize) ||
                other.servingSize == servingSize) &&
            const DeepCollectionEquality()
                .equals(other._nutritionDensity, _nutritionDensity) &&
            const DeepCollectionEquality()
                .equals(other._nutritionContent, _nutritionContent) &&
            const DeepCollectionEquality()
                .equals(other._macronutrients, _macronutrients) &&
            const DeepCollectionEquality()
                .equals(other._aminoAcidProfile, _aminoAcidProfile) &&
            const DeepCollectionEquality()
                .equals(other._fattyAcidProfile, _fattyAcidProfile) &&
            const DeepCollectionEquality()
                .equals(other._antinutrients, _antinutrients) &&
            const DeepCollectionEquality()
                .equals(other._bioactiveCompounds, _bioactiveCompounds) &&
            const DeepCollectionEquality()
                .equals(other._glycemicResponse, _glycemicResponse) &&
            (identical(other.freshnessLevel, freshnessLevel) ||
                other.freshnessLevel == freshnessLevel) &&
            const DeepCollectionEquality()
                .equals(other._seasonalVariation, _seasonalVariation) &&
            const DeepCollectionEquality()
                .equals(other._storageConditions, _storageConditions) &&
            const DeepCollectionEquality()
                .equals(other._originInfo, _originInfo) &&
            const DeepCollectionEquality()
                .equals(other._sustainabilityScore, _sustainabilityScore) &&
            const DeepCollectionEquality()
                .equals(other._allergenInfo, _allergenInfo) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        chineseName,
        scientificName,
        const DeepCollectionEquality().hash(_commonNames),
        category,
        subCategory,
        servingSize,
        const DeepCollectionEquality().hash(_nutritionDensity),
        const DeepCollectionEquality().hash(_nutritionContent),
        const DeepCollectionEquality().hash(_macronutrients),
        const DeepCollectionEquality().hash(_aminoAcidProfile),
        const DeepCollectionEquality().hash(_fattyAcidProfile),
        const DeepCollectionEquality().hash(_antinutrients),
        const DeepCollectionEquality().hash(_bioactiveCompounds),
        const DeepCollectionEquality().hash(_glycemicResponse),
        freshnessLevel,
        const DeepCollectionEquality().hash(_seasonalVariation),
        const DeepCollectionEquality().hash(_storageConditions),
        const DeepCollectionEquality().hash(_originInfo),
        const DeepCollectionEquality().hash(_sustainabilityScore),
        const DeepCollectionEquality().hash(_allergenInfo),
        isActive
      ]);

  /// Create a copy of IngredientNutrition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IngredientNutritionImplCopyWith<_$IngredientNutritionImpl> get copyWith =>
      __$$IngredientNutritionImplCopyWithImpl<_$IngredientNutritionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_IngredientNutrition value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_IngredientNutrition value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_IngredientNutrition value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IngredientNutritionImplToJson(
      this,
    );
  }
}

abstract class _IngredientNutrition implements IngredientNutrition {
  const factory _IngredientNutrition(
      {required final String id,
      required final String name,
      required final String chineseName,
      final String? scientificName,
      final List<String> commonNames,
      required final String category,
      final String? subCategory,
      required final ServingSize servingSize,
      final Map<String, String>? nutritionDensity,
      final List<NutritionContent> nutritionContent,
      final Map<String, dynamic>? macronutrients,
      final Map<String, dynamic>? aminoAcidProfile,
      final List<Map<String, dynamic>> fattyAcidProfile,
      final List<Map<String, dynamic>> antinutrients,
      final List<Map<String, dynamic>> bioactiveCompounds,
      final Map<String, dynamic>? glycemicResponse,
      final String freshnessLevel,
      final Map<String, dynamic>? seasonalVariation,
      final Map<String, dynamic>? storageConditions,
      final Map<String, dynamic>? originInfo,
      final Map<String, dynamic>? sustainabilityScore,
      final Map<String, dynamic>? allergenInfo,
      final bool? isActive}) = _$IngredientNutritionImpl;

  factory _IngredientNutrition.fromJson(Map<String, dynamic> json) =
      _$IngredientNutritionImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get chineseName;
  @override
  String? get scientificName;
  @override
  List<String> get commonNames;
  @override
  String get category;
  @override
  String? get subCategory;
  @override
  ServingSize get servingSize;
  @override
  Map<String, String>? get nutritionDensity;
  @override
  List<NutritionContent> get nutritionContent;
  @override
  Map<String, dynamic>? get macronutrients;
  @override
  Map<String, dynamic>? get aminoAcidProfile;
  @override
  List<Map<String, dynamic>> get fattyAcidProfile;
  @override
  List<Map<String, dynamic>> get antinutrients;
  @override
  List<Map<String, dynamic>> get bioactiveCompounds;
  @override
  Map<String, dynamic>? get glycemicResponse;
  @override
  String get freshnessLevel;
  @override
  Map<String, dynamic>? get seasonalVariation;
  @override
  Map<String, dynamic>? get storageConditions;
  @override
  Map<String, dynamic>? get originInfo;
  @override
  Map<String, dynamic>? get sustainabilityScore;
  @override
  Map<String, dynamic>? get allergenInfo;
  @override
  bool? get isActive;

  /// Create a copy of IngredientNutrition
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IngredientNutritionImplCopyWith<_$IngredientNutritionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ServingSize _$ServingSizeFromJson(Map<String, dynamic> json) {
  return _ServingSize.fromJson(json);
}

/// @nodoc
mixin _$ServingSize {
  double get amount => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ServingSize value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ServingSize value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ServingSize value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this ServingSize to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ServingSize
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ServingSizeCopyWith<ServingSize> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ServingSizeCopyWith<$Res> {
  factory $ServingSizeCopyWith(
          ServingSize value, $Res Function(ServingSize) then) =
      _$ServingSizeCopyWithImpl<$Res, ServingSize>;
  @useResult
  $Res call({double amount, String unit, String? description});
}

/// @nodoc
class _$ServingSizeCopyWithImpl<$Res, $Val extends ServingSize>
    implements $ServingSizeCopyWith<$Res> {
  _$ServingSizeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ServingSize
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = null,
    Object? unit = null,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ServingSizeImplCopyWith<$Res>
    implements $ServingSizeCopyWith<$Res> {
  factory _$$ServingSizeImplCopyWith(
          _$ServingSizeImpl value, $Res Function(_$ServingSizeImpl) then) =
      __$$ServingSizeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double amount, String unit, String? description});
}

/// @nodoc
class __$$ServingSizeImplCopyWithImpl<$Res>
    extends _$ServingSizeCopyWithImpl<$Res, _$ServingSizeImpl>
    implements _$$ServingSizeImplCopyWith<$Res> {
  __$$ServingSizeImplCopyWithImpl(
      _$ServingSizeImpl _value, $Res Function(_$ServingSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ServingSize
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = null,
    Object? unit = null,
    Object? description = freezed,
  }) {
    return _then(_$ServingSizeImpl(
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ServingSizeImpl implements _ServingSize {
  const _$ServingSizeImpl(
      {required this.amount, required this.unit, this.description});

  factory _$ServingSizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ServingSizeImplFromJson(json);

  @override
  final double amount;
  @override
  final String unit;
  @override
  final String? description;

  @override
  String toString() {
    return 'ServingSize(amount: $amount, unit: $unit, description: $description)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ServingSizeImpl &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, amount, unit, description);

  /// Create a copy of ServingSize
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ServingSizeImplCopyWith<_$ServingSizeImpl> get copyWith =>
      __$$ServingSizeImplCopyWithImpl<_$ServingSizeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ServingSize value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ServingSize value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ServingSize value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ServingSizeImplToJson(
      this,
    );
  }
}

abstract class _ServingSize implements ServingSize {
  const factory _ServingSize(
      {required final double amount,
      required final String unit,
      final String? description}) = _$ServingSizeImpl;

  factory _ServingSize.fromJson(Map<String, dynamic> json) =
      _$ServingSizeImpl.fromJson;

  @override
  double get amount;
  @override
  String get unit;
  @override
  String? get description;

  /// Create a copy of ServingSize
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ServingSizeImplCopyWith<_$ServingSizeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NutritionContent _$NutritionContentFromJson(Map<String, dynamic> json) {
  return _NutritionContent.fromJson(json);
}

/// @nodoc
mixin _$NutritionContent {
  String get element => throw _privateConstructorUsedError;
  double get amount => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  double? get dailyValuePercentage => throw _privateConstructorUsedError;
  double get bioavailability => throw _privateConstructorUsedError;
  bool get isEstimated => throw _privateConstructorUsedError;
  DateTime? get lastTested => throw _privateConstructorUsedError;
  String? get testMethod => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionContent value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionContent value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionContent value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionContent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionContentCopyWith<NutritionContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionContentCopyWith<$Res> {
  factory $NutritionContentCopyWith(
          NutritionContent value, $Res Function(NutritionContent) then) =
      _$NutritionContentCopyWithImpl<$Res, NutritionContent>;
  @useResult
  $Res call(
      {String element,
      double amount,
      String unit,
      double? dailyValuePercentage,
      double bioavailability,
      bool isEstimated,
      DateTime? lastTested,
      String? testMethod});
}

/// @nodoc
class _$NutritionContentCopyWithImpl<$Res, $Val extends NutritionContent>
    implements $NutritionContentCopyWith<$Res> {
  _$NutritionContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? element = null,
    Object? amount = null,
    Object? unit = null,
    Object? dailyValuePercentage = freezed,
    Object? bioavailability = null,
    Object? isEstimated = null,
    Object? lastTested = freezed,
    Object? testMethod = freezed,
  }) {
    return _then(_value.copyWith(
      element: null == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      dailyValuePercentage: freezed == dailyValuePercentage
          ? _value.dailyValuePercentage
          : dailyValuePercentage // ignore: cast_nullable_to_non_nullable
              as double?,
      bioavailability: null == bioavailability
          ? _value.bioavailability
          : bioavailability // ignore: cast_nullable_to_non_nullable
              as double,
      isEstimated: null == isEstimated
          ? _value.isEstimated
          : isEstimated // ignore: cast_nullable_to_non_nullable
              as bool,
      lastTested: freezed == lastTested
          ? _value.lastTested
          : lastTested // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      testMethod: freezed == testMethod
          ? _value.testMethod
          : testMethod // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionContentImplCopyWith<$Res>
    implements $NutritionContentCopyWith<$Res> {
  factory _$$NutritionContentImplCopyWith(_$NutritionContentImpl value,
          $Res Function(_$NutritionContentImpl) then) =
      __$$NutritionContentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String element,
      double amount,
      String unit,
      double? dailyValuePercentage,
      double bioavailability,
      bool isEstimated,
      DateTime? lastTested,
      String? testMethod});
}

/// @nodoc
class __$$NutritionContentImplCopyWithImpl<$Res>
    extends _$NutritionContentCopyWithImpl<$Res, _$NutritionContentImpl>
    implements _$$NutritionContentImplCopyWith<$Res> {
  __$$NutritionContentImplCopyWithImpl(_$NutritionContentImpl _value,
      $Res Function(_$NutritionContentImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? element = null,
    Object? amount = null,
    Object? unit = null,
    Object? dailyValuePercentage = freezed,
    Object? bioavailability = null,
    Object? isEstimated = null,
    Object? lastTested = freezed,
    Object? testMethod = freezed,
  }) {
    return _then(_$NutritionContentImpl(
      element: null == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      dailyValuePercentage: freezed == dailyValuePercentage
          ? _value.dailyValuePercentage
          : dailyValuePercentage // ignore: cast_nullable_to_non_nullable
              as double?,
      bioavailability: null == bioavailability
          ? _value.bioavailability
          : bioavailability // ignore: cast_nullable_to_non_nullable
              as double,
      isEstimated: null == isEstimated
          ? _value.isEstimated
          : isEstimated // ignore: cast_nullable_to_non_nullable
              as bool,
      lastTested: freezed == lastTested
          ? _value.lastTested
          : lastTested // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      testMethod: freezed == testMethod
          ? _value.testMethod
          : testMethod // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionContentImpl implements _NutritionContent {
  const _$NutritionContentImpl(
      {required this.element,
      required this.amount,
      required this.unit,
      this.dailyValuePercentage,
      this.bioavailability = 100.0,
      this.isEstimated = false,
      this.lastTested,
      this.testMethod});

  factory _$NutritionContentImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionContentImplFromJson(json);

  @override
  final String element;
  @override
  final double amount;
  @override
  final String unit;
  @override
  final double? dailyValuePercentage;
  @override
  @JsonKey()
  final double bioavailability;
  @override
  @JsonKey()
  final bool isEstimated;
  @override
  final DateTime? lastTested;
  @override
  final String? testMethod;

  @override
  String toString() {
    return 'NutritionContent(element: $element, amount: $amount, unit: $unit, dailyValuePercentage: $dailyValuePercentage, bioavailability: $bioavailability, isEstimated: $isEstimated, lastTested: $lastTested, testMethod: $testMethod)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionContentImpl &&
            (identical(other.element, element) || other.element == element) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.dailyValuePercentage, dailyValuePercentage) ||
                other.dailyValuePercentage == dailyValuePercentage) &&
            (identical(other.bioavailability, bioavailability) ||
                other.bioavailability == bioavailability) &&
            (identical(other.isEstimated, isEstimated) ||
                other.isEstimated == isEstimated) &&
            (identical(other.lastTested, lastTested) ||
                other.lastTested == lastTested) &&
            (identical(other.testMethod, testMethod) ||
                other.testMethod == testMethod));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      element,
      amount,
      unit,
      dailyValuePercentage,
      bioavailability,
      isEstimated,
      lastTested,
      testMethod);

  /// Create a copy of NutritionContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionContentImplCopyWith<_$NutritionContentImpl> get copyWith =>
      __$$NutritionContentImplCopyWithImpl<_$NutritionContentImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionContent value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionContent value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionContent value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionContentImplToJson(
      this,
    );
  }
}

abstract class _NutritionContent implements NutritionContent {
  const factory _NutritionContent(
      {required final String element,
      required final double amount,
      required final String unit,
      final double? dailyValuePercentage,
      final double bioavailability,
      final bool isEstimated,
      final DateTime? lastTested,
      final String? testMethod}) = _$NutritionContentImpl;

  factory _NutritionContent.fromJson(Map<String, dynamic> json) =
      _$NutritionContentImpl.fromJson;

  @override
  String get element;
  @override
  double get amount;
  @override
  String get unit;
  @override
  double? get dailyValuePercentage;
  @override
  double get bioavailability;
  @override
  bool get isEstimated;
  @override
  DateTime? get lastTested;
  @override
  String? get testMethod;

  /// Create a copy of NutritionContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionContentImplCopyWith<_$NutritionContentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CookingMethod _$CookingMethodFromJson(Map<String, dynamic> json) {
  return _CookingMethod.fromJson(json);
}

/// @nodoc
mixin _$CookingMethod {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get chineseName => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  List<String> get aliases => throw _privateConstructorUsedError;
  String get category => throw _privateConstructorUsedError;
  String get method => throw _privateConstructorUsedError;
  Map<String, dynamic>? get technicalParameters =>
      throw _privateConstructorUsedError;
  List<NutritionImpact> get nutritionImpacts =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get overallNutritionRetention =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get temperatureTimeCurves =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get ingredientApplicability =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get nutritionEnhancements =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get harmfulCompounds =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get digestibilityImpact =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get antinutrientImpact =>
      throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get bioactiveImpact =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get equipmentRequirements =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get skillRequirements =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get efficiency => throw _privateConstructorUsedError;
  Map<String, dynamic>? get researchSupport =>
      throw _privateConstructorUsedError;
  bool? get isActive => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CookingMethod value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CookingMethod value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CookingMethod value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this CookingMethod to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CookingMethod
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CookingMethodCopyWith<CookingMethod> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CookingMethodCopyWith<$Res> {
  factory $CookingMethodCopyWith(
          CookingMethod value, $Res Function(CookingMethod) then) =
      _$CookingMethodCopyWithImpl<$Res, CookingMethod>;
  @useResult
  $Res call(
      {String id,
      String name,
      String chineseName,
      String? description,
      List<String> aliases,
      String category,
      String method,
      Map<String, dynamic>? technicalParameters,
      List<NutritionImpact> nutritionImpacts,
      Map<String, dynamic>? overallNutritionRetention,
      List<Map<String, dynamic>> temperatureTimeCurves,
      List<Map<String, dynamic>> ingredientApplicability,
      List<Map<String, dynamic>> nutritionEnhancements,
      List<Map<String, dynamic>> harmfulCompounds,
      Map<String, dynamic>? digestibilityImpact,
      List<Map<String, dynamic>> antinutrientImpact,
      List<Map<String, dynamic>> bioactiveImpact,
      Map<String, dynamic>? equipmentRequirements,
      Map<String, dynamic>? skillRequirements,
      Map<String, dynamic>? efficiency,
      Map<String, dynamic>? researchSupport,
      bool? isActive});
}

/// @nodoc
class _$CookingMethodCopyWithImpl<$Res, $Val extends CookingMethod>
    implements $CookingMethodCopyWith<$Res> {
  _$CookingMethodCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CookingMethod
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? chineseName = null,
    Object? description = freezed,
    Object? aliases = null,
    Object? category = null,
    Object? method = null,
    Object? technicalParameters = freezed,
    Object? nutritionImpacts = null,
    Object? overallNutritionRetention = freezed,
    Object? temperatureTimeCurves = null,
    Object? ingredientApplicability = null,
    Object? nutritionEnhancements = null,
    Object? harmfulCompounds = null,
    Object? digestibilityImpact = freezed,
    Object? antinutrientImpact = null,
    Object? bioactiveImpact = null,
    Object? equipmentRequirements = freezed,
    Object? skillRequirements = freezed,
    Object? efficiency = freezed,
    Object? researchSupport = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chineseName: null == chineseName
          ? _value.chineseName
          : chineseName // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      aliases: null == aliases
          ? _value.aliases
          : aliases // ignore: cast_nullable_to_non_nullable
              as List<String>,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      method: null == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String,
      technicalParameters: freezed == technicalParameters
          ? _value.technicalParameters
          : technicalParameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      nutritionImpacts: null == nutritionImpacts
          ? _value.nutritionImpacts
          : nutritionImpacts // ignore: cast_nullable_to_non_nullable
              as List<NutritionImpact>,
      overallNutritionRetention: freezed == overallNutritionRetention
          ? _value.overallNutritionRetention
          : overallNutritionRetention // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperatureTimeCurves: null == temperatureTimeCurves
          ? _value.temperatureTimeCurves
          : temperatureTimeCurves // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      ingredientApplicability: null == ingredientApplicability
          ? _value.ingredientApplicability
          : ingredientApplicability // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      nutritionEnhancements: null == nutritionEnhancements
          ? _value.nutritionEnhancements
          : nutritionEnhancements // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      harmfulCompounds: null == harmfulCompounds
          ? _value.harmfulCompounds
          : harmfulCompounds // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      digestibilityImpact: freezed == digestibilityImpact
          ? _value.digestibilityImpact
          : digestibilityImpact // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      antinutrientImpact: null == antinutrientImpact
          ? _value.antinutrientImpact
          : antinutrientImpact // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      bioactiveImpact: null == bioactiveImpact
          ? _value.bioactiveImpact
          : bioactiveImpact // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      equipmentRequirements: freezed == equipmentRequirements
          ? _value.equipmentRequirements
          : equipmentRequirements // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      skillRequirements: freezed == skillRequirements
          ? _value.skillRequirements
          : skillRequirements // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      efficiency: freezed == efficiency
          ? _value.efficiency
          : efficiency // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      researchSupport: freezed == researchSupport
          ? _value.researchSupport
          : researchSupport // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CookingMethodImplCopyWith<$Res>
    implements $CookingMethodCopyWith<$Res> {
  factory _$$CookingMethodImplCopyWith(
          _$CookingMethodImpl value, $Res Function(_$CookingMethodImpl) then) =
      __$$CookingMethodImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String chineseName,
      String? description,
      List<String> aliases,
      String category,
      String method,
      Map<String, dynamic>? technicalParameters,
      List<NutritionImpact> nutritionImpacts,
      Map<String, dynamic>? overallNutritionRetention,
      List<Map<String, dynamic>> temperatureTimeCurves,
      List<Map<String, dynamic>> ingredientApplicability,
      List<Map<String, dynamic>> nutritionEnhancements,
      List<Map<String, dynamic>> harmfulCompounds,
      Map<String, dynamic>? digestibilityImpact,
      List<Map<String, dynamic>> antinutrientImpact,
      List<Map<String, dynamic>> bioactiveImpact,
      Map<String, dynamic>? equipmentRequirements,
      Map<String, dynamic>? skillRequirements,
      Map<String, dynamic>? efficiency,
      Map<String, dynamic>? researchSupport,
      bool? isActive});
}

/// @nodoc
class __$$CookingMethodImplCopyWithImpl<$Res>
    extends _$CookingMethodCopyWithImpl<$Res, _$CookingMethodImpl>
    implements _$$CookingMethodImplCopyWith<$Res> {
  __$$CookingMethodImplCopyWithImpl(
      _$CookingMethodImpl _value, $Res Function(_$CookingMethodImpl) _then)
      : super(_value, _then);

  /// Create a copy of CookingMethod
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? chineseName = null,
    Object? description = freezed,
    Object? aliases = null,
    Object? category = null,
    Object? method = null,
    Object? technicalParameters = freezed,
    Object? nutritionImpacts = null,
    Object? overallNutritionRetention = freezed,
    Object? temperatureTimeCurves = null,
    Object? ingredientApplicability = null,
    Object? nutritionEnhancements = null,
    Object? harmfulCompounds = null,
    Object? digestibilityImpact = freezed,
    Object? antinutrientImpact = null,
    Object? bioactiveImpact = null,
    Object? equipmentRequirements = freezed,
    Object? skillRequirements = freezed,
    Object? efficiency = freezed,
    Object? researchSupport = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_$CookingMethodImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chineseName: null == chineseName
          ? _value.chineseName
          : chineseName // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      aliases: null == aliases
          ? _value._aliases
          : aliases // ignore: cast_nullable_to_non_nullable
              as List<String>,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      method: null == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String,
      technicalParameters: freezed == technicalParameters
          ? _value._technicalParameters
          : technicalParameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      nutritionImpacts: null == nutritionImpacts
          ? _value._nutritionImpacts
          : nutritionImpacts // ignore: cast_nullable_to_non_nullable
              as List<NutritionImpact>,
      overallNutritionRetention: freezed == overallNutritionRetention
          ? _value._overallNutritionRetention
          : overallNutritionRetention // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperatureTimeCurves: null == temperatureTimeCurves
          ? _value._temperatureTimeCurves
          : temperatureTimeCurves // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      ingredientApplicability: null == ingredientApplicability
          ? _value._ingredientApplicability
          : ingredientApplicability // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      nutritionEnhancements: null == nutritionEnhancements
          ? _value._nutritionEnhancements
          : nutritionEnhancements // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      harmfulCompounds: null == harmfulCompounds
          ? _value._harmfulCompounds
          : harmfulCompounds // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      digestibilityImpact: freezed == digestibilityImpact
          ? _value._digestibilityImpact
          : digestibilityImpact // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      antinutrientImpact: null == antinutrientImpact
          ? _value._antinutrientImpact
          : antinutrientImpact // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      bioactiveImpact: null == bioactiveImpact
          ? _value._bioactiveImpact
          : bioactiveImpact // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      equipmentRequirements: freezed == equipmentRequirements
          ? _value._equipmentRequirements
          : equipmentRequirements // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      skillRequirements: freezed == skillRequirements
          ? _value._skillRequirements
          : skillRequirements // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      efficiency: freezed == efficiency
          ? _value._efficiency
          : efficiency // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      researchSupport: freezed == researchSupport
          ? _value._researchSupport
          : researchSupport // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CookingMethodImpl implements _CookingMethod {
  const _$CookingMethodImpl(
      {required this.id,
      required this.name,
      required this.chineseName,
      this.description,
      final List<String> aliases = const [],
      required this.category,
      required this.method,
      final Map<String, dynamic>? technicalParameters,
      final List<NutritionImpact> nutritionImpacts = const [],
      final Map<String, dynamic>? overallNutritionRetention,
      final List<Map<String, dynamic>> temperatureTimeCurves = const [],
      final List<Map<String, dynamic>> ingredientApplicability = const [],
      final List<Map<String, dynamic>> nutritionEnhancements = const [],
      final List<Map<String, dynamic>> harmfulCompounds = const [],
      final Map<String, dynamic>? digestibilityImpact,
      final List<Map<String, dynamic>> antinutrientImpact = const [],
      final List<Map<String, dynamic>> bioactiveImpact = const [],
      final Map<String, dynamic>? equipmentRequirements,
      final Map<String, dynamic>? skillRequirements,
      final Map<String, dynamic>? efficiency,
      final Map<String, dynamic>? researchSupport,
      this.isActive})
      : _aliases = aliases,
        _technicalParameters = technicalParameters,
        _nutritionImpacts = nutritionImpacts,
        _overallNutritionRetention = overallNutritionRetention,
        _temperatureTimeCurves = temperatureTimeCurves,
        _ingredientApplicability = ingredientApplicability,
        _nutritionEnhancements = nutritionEnhancements,
        _harmfulCompounds = harmfulCompounds,
        _digestibilityImpact = digestibilityImpact,
        _antinutrientImpact = antinutrientImpact,
        _bioactiveImpact = bioactiveImpact,
        _equipmentRequirements = equipmentRequirements,
        _skillRequirements = skillRequirements,
        _efficiency = efficiency,
        _researchSupport = researchSupport;

  factory _$CookingMethodImpl.fromJson(Map<String, dynamic> json) =>
      _$$CookingMethodImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String chineseName;
  @override
  final String? description;
  final List<String> _aliases;
  @override
  @JsonKey()
  List<String> get aliases {
    if (_aliases is EqualUnmodifiableListView) return _aliases;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_aliases);
  }

  @override
  final String category;
  @override
  final String method;
  final Map<String, dynamic>? _technicalParameters;
  @override
  Map<String, dynamic>? get technicalParameters {
    final value = _technicalParameters;
    if (value == null) return null;
    if (_technicalParameters is EqualUnmodifiableMapView)
      return _technicalParameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<NutritionImpact> _nutritionImpacts;
  @override
  @JsonKey()
  List<NutritionImpact> get nutritionImpacts {
    if (_nutritionImpacts is EqualUnmodifiableListView)
      return _nutritionImpacts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_nutritionImpacts);
  }

  final Map<String, dynamic>? _overallNutritionRetention;
  @override
  Map<String, dynamic>? get overallNutritionRetention {
    final value = _overallNutritionRetention;
    if (value == null) return null;
    if (_overallNutritionRetention is EqualUnmodifiableMapView)
      return _overallNutritionRetention;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<Map<String, dynamic>> _temperatureTimeCurves;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get temperatureTimeCurves {
    if (_temperatureTimeCurves is EqualUnmodifiableListView)
      return _temperatureTimeCurves;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_temperatureTimeCurves);
  }

  final List<Map<String, dynamic>> _ingredientApplicability;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get ingredientApplicability {
    if (_ingredientApplicability is EqualUnmodifiableListView)
      return _ingredientApplicability;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_ingredientApplicability);
  }

  final List<Map<String, dynamic>> _nutritionEnhancements;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get nutritionEnhancements {
    if (_nutritionEnhancements is EqualUnmodifiableListView)
      return _nutritionEnhancements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_nutritionEnhancements);
  }

  final List<Map<String, dynamic>> _harmfulCompounds;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get harmfulCompounds {
    if (_harmfulCompounds is EqualUnmodifiableListView)
      return _harmfulCompounds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_harmfulCompounds);
  }

  final Map<String, dynamic>? _digestibilityImpact;
  @override
  Map<String, dynamic>? get digestibilityImpact {
    final value = _digestibilityImpact;
    if (value == null) return null;
    if (_digestibilityImpact is EqualUnmodifiableMapView)
      return _digestibilityImpact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<Map<String, dynamic>> _antinutrientImpact;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get antinutrientImpact {
    if (_antinutrientImpact is EqualUnmodifiableListView)
      return _antinutrientImpact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_antinutrientImpact);
  }

  final List<Map<String, dynamic>> _bioactiveImpact;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get bioactiveImpact {
    if (_bioactiveImpact is EqualUnmodifiableListView) return _bioactiveImpact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bioactiveImpact);
  }

  final Map<String, dynamic>? _equipmentRequirements;
  @override
  Map<String, dynamic>? get equipmentRequirements {
    final value = _equipmentRequirements;
    if (value == null) return null;
    if (_equipmentRequirements is EqualUnmodifiableMapView)
      return _equipmentRequirements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _skillRequirements;
  @override
  Map<String, dynamic>? get skillRequirements {
    final value = _skillRequirements;
    if (value == null) return null;
    if (_skillRequirements is EqualUnmodifiableMapView)
      return _skillRequirements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _efficiency;
  @override
  Map<String, dynamic>? get efficiency {
    final value = _efficiency;
    if (value == null) return null;
    if (_efficiency is EqualUnmodifiableMapView) return _efficiency;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _researchSupport;
  @override
  Map<String, dynamic>? get researchSupport {
    final value = _researchSupport;
    if (value == null) return null;
    if (_researchSupport is EqualUnmodifiableMapView) return _researchSupport;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final bool? isActive;

  @override
  String toString() {
    return 'CookingMethod(id: $id, name: $name, chineseName: $chineseName, description: $description, aliases: $aliases, category: $category, method: $method, technicalParameters: $technicalParameters, nutritionImpacts: $nutritionImpacts, overallNutritionRetention: $overallNutritionRetention, temperatureTimeCurves: $temperatureTimeCurves, ingredientApplicability: $ingredientApplicability, nutritionEnhancements: $nutritionEnhancements, harmfulCompounds: $harmfulCompounds, digestibilityImpact: $digestibilityImpact, antinutrientImpact: $antinutrientImpact, bioactiveImpact: $bioactiveImpact, equipmentRequirements: $equipmentRequirements, skillRequirements: $skillRequirements, efficiency: $efficiency, researchSupport: $researchSupport, isActive: $isActive)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CookingMethodImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.chineseName, chineseName) ||
                other.chineseName == chineseName) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._aliases, _aliases) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.method, method) || other.method == method) &&
            const DeepCollectionEquality()
                .equals(other._technicalParameters, _technicalParameters) &&
            const DeepCollectionEquality()
                .equals(other._nutritionImpacts, _nutritionImpacts) &&
            const DeepCollectionEquality().equals(
                other._overallNutritionRetention, _overallNutritionRetention) &&
            const DeepCollectionEquality()
                .equals(other._temperatureTimeCurves, _temperatureTimeCurves) &&
            const DeepCollectionEquality().equals(
                other._ingredientApplicability, _ingredientApplicability) &&
            const DeepCollectionEquality()
                .equals(other._nutritionEnhancements, _nutritionEnhancements) &&
            const DeepCollectionEquality()
                .equals(other._harmfulCompounds, _harmfulCompounds) &&
            const DeepCollectionEquality()
                .equals(other._digestibilityImpact, _digestibilityImpact) &&
            const DeepCollectionEquality()
                .equals(other._antinutrientImpact, _antinutrientImpact) &&
            const DeepCollectionEquality()
                .equals(other._bioactiveImpact, _bioactiveImpact) &&
            const DeepCollectionEquality()
                .equals(other._equipmentRequirements, _equipmentRequirements) &&
            const DeepCollectionEquality()
                .equals(other._skillRequirements, _skillRequirements) &&
            const DeepCollectionEquality()
                .equals(other._efficiency, _efficiency) &&
            const DeepCollectionEquality()
                .equals(other._researchSupport, _researchSupport) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        chineseName,
        description,
        const DeepCollectionEquality().hash(_aliases),
        category,
        method,
        const DeepCollectionEquality().hash(_technicalParameters),
        const DeepCollectionEquality().hash(_nutritionImpacts),
        const DeepCollectionEquality().hash(_overallNutritionRetention),
        const DeepCollectionEquality().hash(_temperatureTimeCurves),
        const DeepCollectionEquality().hash(_ingredientApplicability),
        const DeepCollectionEquality().hash(_nutritionEnhancements),
        const DeepCollectionEquality().hash(_harmfulCompounds),
        const DeepCollectionEquality().hash(_digestibilityImpact),
        const DeepCollectionEquality().hash(_antinutrientImpact),
        const DeepCollectionEquality().hash(_bioactiveImpact),
        const DeepCollectionEquality().hash(_equipmentRequirements),
        const DeepCollectionEquality().hash(_skillRequirements),
        const DeepCollectionEquality().hash(_efficiency),
        const DeepCollectionEquality().hash(_researchSupport),
        isActive
      ]);

  /// Create a copy of CookingMethod
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CookingMethodImplCopyWith<_$CookingMethodImpl> get copyWith =>
      __$$CookingMethodImplCopyWithImpl<_$CookingMethodImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CookingMethod value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CookingMethod value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CookingMethod value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CookingMethodImplToJson(
      this,
    );
  }
}

abstract class _CookingMethod implements CookingMethod {
  const factory _CookingMethod(
      {required final String id,
      required final String name,
      required final String chineseName,
      final String? description,
      final List<String> aliases,
      required final String category,
      required final String method,
      final Map<String, dynamic>? technicalParameters,
      final List<NutritionImpact> nutritionImpacts,
      final Map<String, dynamic>? overallNutritionRetention,
      final List<Map<String, dynamic>> temperatureTimeCurves,
      final List<Map<String, dynamic>> ingredientApplicability,
      final List<Map<String, dynamic>> nutritionEnhancements,
      final List<Map<String, dynamic>> harmfulCompounds,
      final Map<String, dynamic>? digestibilityImpact,
      final List<Map<String, dynamic>> antinutrientImpact,
      final List<Map<String, dynamic>> bioactiveImpact,
      final Map<String, dynamic>? equipmentRequirements,
      final Map<String, dynamic>? skillRequirements,
      final Map<String, dynamic>? efficiency,
      final Map<String, dynamic>? researchSupport,
      final bool? isActive}) = _$CookingMethodImpl;

  factory _CookingMethod.fromJson(Map<String, dynamic> json) =
      _$CookingMethodImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get chineseName;
  @override
  String? get description;
  @override
  List<String> get aliases;
  @override
  String get category;
  @override
  String get method;
  @override
  Map<String, dynamic>? get technicalParameters;
  @override
  List<NutritionImpact> get nutritionImpacts;
  @override
  Map<String, dynamic>? get overallNutritionRetention;
  @override
  List<Map<String, dynamic>> get temperatureTimeCurves;
  @override
  List<Map<String, dynamic>> get ingredientApplicability;
  @override
  List<Map<String, dynamic>> get nutritionEnhancements;
  @override
  List<Map<String, dynamic>> get harmfulCompounds;
  @override
  Map<String, dynamic>? get digestibilityImpact;
  @override
  List<Map<String, dynamic>> get antinutrientImpact;
  @override
  List<Map<String, dynamic>> get bioactiveImpact;
  @override
  Map<String, dynamic>? get equipmentRequirements;
  @override
  Map<String, dynamic>? get skillRequirements;
  @override
  Map<String, dynamic>? get efficiency;
  @override
  Map<String, dynamic>? get researchSupport;
  @override
  bool? get isActive;

  /// Create a copy of CookingMethod
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CookingMethodImplCopyWith<_$CookingMethodImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NutritionImpact _$NutritionImpactFromJson(Map<String, dynamic> json) {
  return _NutritionImpact.fromJson(json);
}

/// @nodoc
mixin _$NutritionImpact {
  String get nutrient => throw _privateConstructorUsedError;
  String get impactType => throw _privateConstructorUsedError;
  double? get retentionRate => throw _privateConstructorUsedError;
  Map<String, double>? get variationRange => throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get influencingFactors =>
      throw _privateConstructorUsedError;
  String? get mechanism => throw _privateConstructorUsedError;
  bool get timeDependent => throw _privateConstructorUsedError;
  List<Map<String, dynamic>> get timeCurve =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionImpact value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionImpact value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionImpact value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionImpact to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionImpact
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionImpactCopyWith<NutritionImpact> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionImpactCopyWith<$Res> {
  factory $NutritionImpactCopyWith(
          NutritionImpact value, $Res Function(NutritionImpact) then) =
      _$NutritionImpactCopyWithImpl<$Res, NutritionImpact>;
  @useResult
  $Res call(
      {String nutrient,
      String impactType,
      double? retentionRate,
      Map<String, double>? variationRange,
      List<Map<String, dynamic>> influencingFactors,
      String? mechanism,
      bool timeDependent,
      List<Map<String, dynamic>> timeCurve});
}

/// @nodoc
class _$NutritionImpactCopyWithImpl<$Res, $Val extends NutritionImpact>
    implements $NutritionImpactCopyWith<$Res> {
  _$NutritionImpactCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionImpact
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nutrient = null,
    Object? impactType = null,
    Object? retentionRate = freezed,
    Object? variationRange = freezed,
    Object? influencingFactors = null,
    Object? mechanism = freezed,
    Object? timeDependent = null,
    Object? timeCurve = null,
  }) {
    return _then(_value.copyWith(
      nutrient: null == nutrient
          ? _value.nutrient
          : nutrient // ignore: cast_nullable_to_non_nullable
              as String,
      impactType: null == impactType
          ? _value.impactType
          : impactType // ignore: cast_nullable_to_non_nullable
              as String,
      retentionRate: freezed == retentionRate
          ? _value.retentionRate
          : retentionRate // ignore: cast_nullable_to_non_nullable
              as double?,
      variationRange: freezed == variationRange
          ? _value.variationRange
          : variationRange // ignore: cast_nullable_to_non_nullable
              as Map<String, double>?,
      influencingFactors: null == influencingFactors
          ? _value.influencingFactors
          : influencingFactors // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      mechanism: freezed == mechanism
          ? _value.mechanism
          : mechanism // ignore: cast_nullable_to_non_nullable
              as String?,
      timeDependent: null == timeDependent
          ? _value.timeDependent
          : timeDependent // ignore: cast_nullable_to_non_nullable
              as bool,
      timeCurve: null == timeCurve
          ? _value.timeCurve
          : timeCurve // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionImpactImplCopyWith<$Res>
    implements $NutritionImpactCopyWith<$Res> {
  factory _$$NutritionImpactImplCopyWith(_$NutritionImpactImpl value,
          $Res Function(_$NutritionImpactImpl) then) =
      __$$NutritionImpactImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String nutrient,
      String impactType,
      double? retentionRate,
      Map<String, double>? variationRange,
      List<Map<String, dynamic>> influencingFactors,
      String? mechanism,
      bool timeDependent,
      List<Map<String, dynamic>> timeCurve});
}

/// @nodoc
class __$$NutritionImpactImplCopyWithImpl<$Res>
    extends _$NutritionImpactCopyWithImpl<$Res, _$NutritionImpactImpl>
    implements _$$NutritionImpactImplCopyWith<$Res> {
  __$$NutritionImpactImplCopyWithImpl(
      _$NutritionImpactImpl _value, $Res Function(_$NutritionImpactImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionImpact
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nutrient = null,
    Object? impactType = null,
    Object? retentionRate = freezed,
    Object? variationRange = freezed,
    Object? influencingFactors = null,
    Object? mechanism = freezed,
    Object? timeDependent = null,
    Object? timeCurve = null,
  }) {
    return _then(_$NutritionImpactImpl(
      nutrient: null == nutrient
          ? _value.nutrient
          : nutrient // ignore: cast_nullable_to_non_nullable
              as String,
      impactType: null == impactType
          ? _value.impactType
          : impactType // ignore: cast_nullable_to_non_nullable
              as String,
      retentionRate: freezed == retentionRate
          ? _value.retentionRate
          : retentionRate // ignore: cast_nullable_to_non_nullable
              as double?,
      variationRange: freezed == variationRange
          ? _value._variationRange
          : variationRange // ignore: cast_nullable_to_non_nullable
              as Map<String, double>?,
      influencingFactors: null == influencingFactors
          ? _value._influencingFactors
          : influencingFactors // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      mechanism: freezed == mechanism
          ? _value.mechanism
          : mechanism // ignore: cast_nullable_to_non_nullable
              as String?,
      timeDependent: null == timeDependent
          ? _value.timeDependent
          : timeDependent // ignore: cast_nullable_to_non_nullable
              as bool,
      timeCurve: null == timeCurve
          ? _value._timeCurve
          : timeCurve // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionImpactImpl implements _NutritionImpact {
  const _$NutritionImpactImpl(
      {required this.nutrient,
      required this.impactType,
      this.retentionRate,
      final Map<String, double>? variationRange,
      final List<Map<String, dynamic>> influencingFactors = const [],
      this.mechanism,
      this.timeDependent = false,
      final List<Map<String, dynamic>> timeCurve = const []})
      : _variationRange = variationRange,
        _influencingFactors = influencingFactors,
        _timeCurve = timeCurve;

  factory _$NutritionImpactImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionImpactImplFromJson(json);

  @override
  final String nutrient;
  @override
  final String impactType;
  @override
  final double? retentionRate;
  final Map<String, double>? _variationRange;
  @override
  Map<String, double>? get variationRange {
    final value = _variationRange;
    if (value == null) return null;
    if (_variationRange is EqualUnmodifiableMapView) return _variationRange;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<Map<String, dynamic>> _influencingFactors;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get influencingFactors {
    if (_influencingFactors is EqualUnmodifiableListView)
      return _influencingFactors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_influencingFactors);
  }

  @override
  final String? mechanism;
  @override
  @JsonKey()
  final bool timeDependent;
  final List<Map<String, dynamic>> _timeCurve;
  @override
  @JsonKey()
  List<Map<String, dynamic>> get timeCurve {
    if (_timeCurve is EqualUnmodifiableListView) return _timeCurve;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_timeCurve);
  }

  @override
  String toString() {
    return 'NutritionImpact(nutrient: $nutrient, impactType: $impactType, retentionRate: $retentionRate, variationRange: $variationRange, influencingFactors: $influencingFactors, mechanism: $mechanism, timeDependent: $timeDependent, timeCurve: $timeCurve)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionImpactImpl &&
            (identical(other.nutrient, nutrient) ||
                other.nutrient == nutrient) &&
            (identical(other.impactType, impactType) ||
                other.impactType == impactType) &&
            (identical(other.retentionRate, retentionRate) ||
                other.retentionRate == retentionRate) &&
            const DeepCollectionEquality()
                .equals(other._variationRange, _variationRange) &&
            const DeepCollectionEquality()
                .equals(other._influencingFactors, _influencingFactors) &&
            (identical(other.mechanism, mechanism) ||
                other.mechanism == mechanism) &&
            (identical(other.timeDependent, timeDependent) ||
                other.timeDependent == timeDependent) &&
            const DeepCollectionEquality()
                .equals(other._timeCurve, _timeCurve));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      nutrient,
      impactType,
      retentionRate,
      const DeepCollectionEquality().hash(_variationRange),
      const DeepCollectionEquality().hash(_influencingFactors),
      mechanism,
      timeDependent,
      const DeepCollectionEquality().hash(_timeCurve));

  /// Create a copy of NutritionImpact
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionImpactImplCopyWith<_$NutritionImpactImpl> get copyWith =>
      __$$NutritionImpactImplCopyWithImpl<_$NutritionImpactImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionImpact value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionImpact value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionImpact value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionImpactImplToJson(
      this,
    );
  }
}

abstract class _NutritionImpact implements NutritionImpact {
  const factory _NutritionImpact(
      {required final String nutrient,
      required final String impactType,
      final double? retentionRate,
      final Map<String, double>? variationRange,
      final List<Map<String, dynamic>> influencingFactors,
      final String? mechanism,
      final bool timeDependent,
      final List<Map<String, dynamic>> timeCurve}) = _$NutritionImpactImpl;

  factory _NutritionImpact.fromJson(Map<String, dynamic> json) =
      _$NutritionImpactImpl.fromJson;

  @override
  String get nutrient;
  @override
  String get impactType;
  @override
  double? get retentionRate;
  @override
  Map<String, double>? get variationRange;
  @override
  List<Map<String, dynamic>> get influencingFactors;
  @override
  String? get mechanism;
  @override
  bool get timeDependent;
  @override
  List<Map<String, dynamic>> get timeCurve;

  /// Create a copy of NutritionImpact
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionImpactImplCopyWith<_$NutritionImpactImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NutritionNeedsAnalysis _$NutritionNeedsAnalysisFromJson(
    Map<String, dynamic> json) {
  return _NutritionNeedsAnalysis.fromJson(json);
}

/// @nodoc
mixin _$NutritionNeedsAnalysis {
  String get userId => throw _privateConstructorUsedError;
  String get profileId => throw _privateConstructorUsedError;
  double get bmr => throw _privateConstructorUsedError;
  double get tdee => throw _privateConstructorUsedError;
  Map<String, dynamic> get dailyNeeds => throw _privateConstructorUsedError;
  DateTime? get calculatedAt => throw _privateConstructorUsedError;
  DateTime? get validUntil => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionNeedsAnalysis value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionNeedsAnalysis value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionNeedsAnalysis value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionNeedsAnalysis to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionNeedsAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionNeedsAnalysisCopyWith<NutritionNeedsAnalysis> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionNeedsAnalysisCopyWith<$Res> {
  factory $NutritionNeedsAnalysisCopyWith(NutritionNeedsAnalysis value,
          $Res Function(NutritionNeedsAnalysis) then) =
      _$NutritionNeedsAnalysisCopyWithImpl<$Res, NutritionNeedsAnalysis>;
  @useResult
  $Res call(
      {String userId,
      String profileId,
      double bmr,
      double tdee,
      Map<String, dynamic> dailyNeeds,
      DateTime? calculatedAt,
      DateTime? validUntil});
}

/// @nodoc
class _$NutritionNeedsAnalysisCopyWithImpl<$Res,
        $Val extends NutritionNeedsAnalysis>
    implements $NutritionNeedsAnalysisCopyWith<$Res> {
  _$NutritionNeedsAnalysisCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionNeedsAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? profileId = null,
    Object? bmr = null,
    Object? tdee = null,
    Object? dailyNeeds = null,
    Object? calculatedAt = freezed,
    Object? validUntil = freezed,
  }) {
    return _then(_value.copyWith(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      profileId: null == profileId
          ? _value.profileId
          : profileId // ignore: cast_nullable_to_non_nullable
              as String,
      bmr: null == bmr
          ? _value.bmr
          : bmr // ignore: cast_nullable_to_non_nullable
              as double,
      tdee: null == tdee
          ? _value.tdee
          : tdee // ignore: cast_nullable_to_non_nullable
              as double,
      dailyNeeds: null == dailyNeeds
          ? _value.dailyNeeds
          : dailyNeeds // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      calculatedAt: freezed == calculatedAt
          ? _value.calculatedAt
          : calculatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      validUntil: freezed == validUntil
          ? _value.validUntil
          : validUntil // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionNeedsAnalysisImplCopyWith<$Res>
    implements $NutritionNeedsAnalysisCopyWith<$Res> {
  factory _$$NutritionNeedsAnalysisImplCopyWith(
          _$NutritionNeedsAnalysisImpl value,
          $Res Function(_$NutritionNeedsAnalysisImpl) then) =
      __$$NutritionNeedsAnalysisImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String userId,
      String profileId,
      double bmr,
      double tdee,
      Map<String, dynamic> dailyNeeds,
      DateTime? calculatedAt,
      DateTime? validUntil});
}

/// @nodoc
class __$$NutritionNeedsAnalysisImplCopyWithImpl<$Res>
    extends _$NutritionNeedsAnalysisCopyWithImpl<$Res,
        _$NutritionNeedsAnalysisImpl>
    implements _$$NutritionNeedsAnalysisImplCopyWith<$Res> {
  __$$NutritionNeedsAnalysisImplCopyWithImpl(
      _$NutritionNeedsAnalysisImpl _value,
      $Res Function(_$NutritionNeedsAnalysisImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionNeedsAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? profileId = null,
    Object? bmr = null,
    Object? tdee = null,
    Object? dailyNeeds = null,
    Object? calculatedAt = freezed,
    Object? validUntil = freezed,
  }) {
    return _then(_$NutritionNeedsAnalysisImpl(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      profileId: null == profileId
          ? _value.profileId
          : profileId // ignore: cast_nullable_to_non_nullable
              as String,
      bmr: null == bmr
          ? _value.bmr
          : bmr // ignore: cast_nullable_to_non_nullable
              as double,
      tdee: null == tdee
          ? _value.tdee
          : tdee // ignore: cast_nullable_to_non_nullable
              as double,
      dailyNeeds: null == dailyNeeds
          ? _value._dailyNeeds
          : dailyNeeds // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      calculatedAt: freezed == calculatedAt
          ? _value.calculatedAt
          : calculatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      validUntil: freezed == validUntil
          ? _value.validUntil
          : validUntil // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionNeedsAnalysisImpl implements _NutritionNeedsAnalysis {
  const _$NutritionNeedsAnalysisImpl(
      {required this.userId,
      required this.profileId,
      required this.bmr,
      required this.tdee,
      required final Map<String, dynamic> dailyNeeds,
      this.calculatedAt,
      this.validUntil})
      : _dailyNeeds = dailyNeeds;

  factory _$NutritionNeedsAnalysisImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionNeedsAnalysisImplFromJson(json);

  @override
  final String userId;
  @override
  final String profileId;
  @override
  final double bmr;
  @override
  final double tdee;
  final Map<String, dynamic> _dailyNeeds;
  @override
  Map<String, dynamic> get dailyNeeds {
    if (_dailyNeeds is EqualUnmodifiableMapView) return _dailyNeeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_dailyNeeds);
  }

  @override
  final DateTime? calculatedAt;
  @override
  final DateTime? validUntil;

  @override
  String toString() {
    return 'NutritionNeedsAnalysis(userId: $userId, profileId: $profileId, bmr: $bmr, tdee: $tdee, dailyNeeds: $dailyNeeds, calculatedAt: $calculatedAt, validUntil: $validUntil)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionNeedsAnalysisImpl &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.profileId, profileId) ||
                other.profileId == profileId) &&
            (identical(other.bmr, bmr) || other.bmr == bmr) &&
            (identical(other.tdee, tdee) || other.tdee == tdee) &&
            const DeepCollectionEquality()
                .equals(other._dailyNeeds, _dailyNeeds) &&
            (identical(other.calculatedAt, calculatedAt) ||
                other.calculatedAt == calculatedAt) &&
            (identical(other.validUntil, validUntil) ||
                other.validUntil == validUntil));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      userId,
      profileId,
      bmr,
      tdee,
      const DeepCollectionEquality().hash(_dailyNeeds),
      calculatedAt,
      validUntil);

  /// Create a copy of NutritionNeedsAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionNeedsAnalysisImplCopyWith<_$NutritionNeedsAnalysisImpl>
      get copyWith => __$$NutritionNeedsAnalysisImplCopyWithImpl<
          _$NutritionNeedsAnalysisImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionNeedsAnalysis value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionNeedsAnalysis value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionNeedsAnalysis value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionNeedsAnalysisImplToJson(
      this,
    );
  }
}

abstract class _NutritionNeedsAnalysis implements NutritionNeedsAnalysis {
  const factory _NutritionNeedsAnalysis(
      {required final String userId,
      required final String profileId,
      required final double bmr,
      required final double tdee,
      required final Map<String, dynamic> dailyNeeds,
      final DateTime? calculatedAt,
      final DateTime? validUntil}) = _$NutritionNeedsAnalysisImpl;

  factory _NutritionNeedsAnalysis.fromJson(Map<String, dynamic> json) =
      _$NutritionNeedsAnalysisImpl.fromJson;

  @override
  String get userId;
  @override
  String get profileId;
  @override
  double get bmr;
  @override
  double get tdee;
  @override
  Map<String, dynamic> get dailyNeeds;
  @override
  DateTime? get calculatedAt;
  @override
  DateTime? get validUntil;

  /// Create a copy of NutritionNeedsAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionNeedsAnalysisImplCopyWith<_$NutritionNeedsAnalysisImpl>
      get copyWith => throw _privateConstructorUsedError;
}

OrderingSelection _$OrderingSelectionFromJson(Map<String, dynamic> json) {
  return _OrderingSelection.fromJson(json);
}

/// @nodoc
mixin _$OrderingSelection {
  String get ingredientId => throw _privateConstructorUsedError;
  String get ingredientName => throw _privateConstructorUsedError;
  double get amount => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  String? get cookingMethod => throw _privateConstructorUsedError;
  String? get cookingMethodName => throw _privateConstructorUsedError;
  Map<String, dynamic>? get nutritionCalculation =>
      throw _privateConstructorUsedError;
  DateTime? get selectedAt => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_OrderingSelection value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_OrderingSelection value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_OrderingSelection value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this OrderingSelection to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrderingSelection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrderingSelectionCopyWith<OrderingSelection> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderingSelectionCopyWith<$Res> {
  factory $OrderingSelectionCopyWith(
          OrderingSelection value, $Res Function(OrderingSelection) then) =
      _$OrderingSelectionCopyWithImpl<$Res, OrderingSelection>;
  @useResult
  $Res call(
      {String ingredientId,
      String ingredientName,
      double amount,
      String unit,
      String? cookingMethod,
      String? cookingMethodName,
      Map<String, dynamic>? nutritionCalculation,
      DateTime? selectedAt});
}

/// @nodoc
class _$OrderingSelectionCopyWithImpl<$Res, $Val extends OrderingSelection>
    implements $OrderingSelectionCopyWith<$Res> {
  _$OrderingSelectionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrderingSelection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ingredientId = null,
    Object? ingredientName = null,
    Object? amount = null,
    Object? unit = null,
    Object? cookingMethod = freezed,
    Object? cookingMethodName = freezed,
    Object? nutritionCalculation = freezed,
    Object? selectedAt = freezed,
  }) {
    return _then(_value.copyWith(
      ingredientId: null == ingredientId
          ? _value.ingredientId
          : ingredientId // ignore: cast_nullable_to_non_nullable
              as String,
      ingredientName: null == ingredientName
          ? _value.ingredientName
          : ingredientName // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      cookingMethod: freezed == cookingMethod
          ? _value.cookingMethod
          : cookingMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      cookingMethodName: freezed == cookingMethodName
          ? _value.cookingMethodName
          : cookingMethodName // ignore: cast_nullable_to_non_nullable
              as String?,
      nutritionCalculation: freezed == nutritionCalculation
          ? _value.nutritionCalculation
          : nutritionCalculation // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      selectedAt: freezed == selectedAt
          ? _value.selectedAt
          : selectedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$OrderingSelectionImplCopyWith<$Res>
    implements $OrderingSelectionCopyWith<$Res> {
  factory _$$OrderingSelectionImplCopyWith(_$OrderingSelectionImpl value,
          $Res Function(_$OrderingSelectionImpl) then) =
      __$$OrderingSelectionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String ingredientId,
      String ingredientName,
      double amount,
      String unit,
      String? cookingMethod,
      String? cookingMethodName,
      Map<String, dynamic>? nutritionCalculation,
      DateTime? selectedAt});
}

/// @nodoc
class __$$OrderingSelectionImplCopyWithImpl<$Res>
    extends _$OrderingSelectionCopyWithImpl<$Res, _$OrderingSelectionImpl>
    implements _$$OrderingSelectionImplCopyWith<$Res> {
  __$$OrderingSelectionImplCopyWithImpl(_$OrderingSelectionImpl _value,
      $Res Function(_$OrderingSelectionImpl) _then)
      : super(_value, _then);

  /// Create a copy of OrderingSelection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ingredientId = null,
    Object? ingredientName = null,
    Object? amount = null,
    Object? unit = null,
    Object? cookingMethod = freezed,
    Object? cookingMethodName = freezed,
    Object? nutritionCalculation = freezed,
    Object? selectedAt = freezed,
  }) {
    return _then(_$OrderingSelectionImpl(
      ingredientId: null == ingredientId
          ? _value.ingredientId
          : ingredientId // ignore: cast_nullable_to_non_nullable
              as String,
      ingredientName: null == ingredientName
          ? _value.ingredientName
          : ingredientName // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      cookingMethod: freezed == cookingMethod
          ? _value.cookingMethod
          : cookingMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      cookingMethodName: freezed == cookingMethodName
          ? _value.cookingMethodName
          : cookingMethodName // ignore: cast_nullable_to_non_nullable
              as String?,
      nutritionCalculation: freezed == nutritionCalculation
          ? _value._nutritionCalculation
          : nutritionCalculation // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      selectedAt: freezed == selectedAt
          ? _value.selectedAt
          : selectedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OrderingSelectionImpl implements _OrderingSelection {
  const _$OrderingSelectionImpl(
      {required this.ingredientId,
      required this.ingredientName,
      required this.amount,
      required this.unit,
      this.cookingMethod,
      this.cookingMethodName,
      final Map<String, dynamic>? nutritionCalculation,
      this.selectedAt})
      : _nutritionCalculation = nutritionCalculation;

  factory _$OrderingSelectionImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrderingSelectionImplFromJson(json);

  @override
  final String ingredientId;
  @override
  final String ingredientName;
  @override
  final double amount;
  @override
  final String unit;
  @override
  final String? cookingMethod;
  @override
  final String? cookingMethodName;
  final Map<String, dynamic>? _nutritionCalculation;
  @override
  Map<String, dynamic>? get nutritionCalculation {
    final value = _nutritionCalculation;
    if (value == null) return null;
    if (_nutritionCalculation is EqualUnmodifiableMapView)
      return _nutritionCalculation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final DateTime? selectedAt;

  @override
  String toString() {
    return 'OrderingSelection(ingredientId: $ingredientId, ingredientName: $ingredientName, amount: $amount, unit: $unit, cookingMethod: $cookingMethod, cookingMethodName: $cookingMethodName, nutritionCalculation: $nutritionCalculation, selectedAt: $selectedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrderingSelectionImpl &&
            (identical(other.ingredientId, ingredientId) ||
                other.ingredientId == ingredientId) &&
            (identical(other.ingredientName, ingredientName) ||
                other.ingredientName == ingredientName) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.cookingMethod, cookingMethod) ||
                other.cookingMethod == cookingMethod) &&
            (identical(other.cookingMethodName, cookingMethodName) ||
                other.cookingMethodName == cookingMethodName) &&
            const DeepCollectionEquality()
                .equals(other._nutritionCalculation, _nutritionCalculation) &&
            (identical(other.selectedAt, selectedAt) ||
                other.selectedAt == selectedAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      ingredientId,
      ingredientName,
      amount,
      unit,
      cookingMethod,
      cookingMethodName,
      const DeepCollectionEquality().hash(_nutritionCalculation),
      selectedAt);

  /// Create a copy of OrderingSelection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrderingSelectionImplCopyWith<_$OrderingSelectionImpl> get copyWith =>
      __$$OrderingSelectionImplCopyWithImpl<_$OrderingSelectionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_OrderingSelection value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_OrderingSelection value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_OrderingSelection value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$OrderingSelectionImplToJson(
      this,
    );
  }
}

abstract class _OrderingSelection implements OrderingSelection {
  const factory _OrderingSelection(
      {required final String ingredientId,
      required final String ingredientName,
      required final double amount,
      required final String unit,
      final String? cookingMethod,
      final String? cookingMethodName,
      final Map<String, dynamic>? nutritionCalculation,
      final DateTime? selectedAt}) = _$OrderingSelectionImpl;

  factory _OrderingSelection.fromJson(Map<String, dynamic> json) =
      _$OrderingSelectionImpl.fromJson;

  @override
  String get ingredientId;
  @override
  String get ingredientName;
  @override
  double get amount;
  @override
  String get unit;
  @override
  String? get cookingMethod;
  @override
  String? get cookingMethodName;
  @override
  Map<String, dynamic>? get nutritionCalculation;
  @override
  DateTime? get selectedAt;

  /// Create a copy of OrderingSelection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrderingSelectionImplCopyWith<_$OrderingSelectionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NutritionBalanceAnalysis _$NutritionBalanceAnalysisFromJson(
    Map<String, dynamic> json) {
  return _NutritionBalanceAnalysis.fromJson(json);
}

/// @nodoc
mixin _$NutritionBalanceAnalysis {
  double get overallMatch => throw _privateConstructorUsedError;
  Map<String, dynamic> get macroMatch => throw _privateConstructorUsedError;
  Map<String, dynamic> get microMatch => throw _privateConstructorUsedError;
  List<NutritionGap> get gaps => throw _privateConstructorUsedError;
  List<NutritionExcess> get excesses => throw _privateConstructorUsedError;
  List<String> get recommendations => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionBalanceAnalysis value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionBalanceAnalysis value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionBalanceAnalysis value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionBalanceAnalysis to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionBalanceAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionBalanceAnalysisCopyWith<NutritionBalanceAnalysis> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionBalanceAnalysisCopyWith<$Res> {
  factory $NutritionBalanceAnalysisCopyWith(NutritionBalanceAnalysis value,
          $Res Function(NutritionBalanceAnalysis) then) =
      _$NutritionBalanceAnalysisCopyWithImpl<$Res, NutritionBalanceAnalysis>;
  @useResult
  $Res call(
      {double overallMatch,
      Map<String, dynamic> macroMatch,
      Map<String, dynamic> microMatch,
      List<NutritionGap> gaps,
      List<NutritionExcess> excesses,
      List<String> recommendations});
}

/// @nodoc
class _$NutritionBalanceAnalysisCopyWithImpl<$Res,
        $Val extends NutritionBalanceAnalysis>
    implements $NutritionBalanceAnalysisCopyWith<$Res> {
  _$NutritionBalanceAnalysisCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionBalanceAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? overallMatch = null,
    Object? macroMatch = null,
    Object? microMatch = null,
    Object? gaps = null,
    Object? excesses = null,
    Object? recommendations = null,
  }) {
    return _then(_value.copyWith(
      overallMatch: null == overallMatch
          ? _value.overallMatch
          : overallMatch // ignore: cast_nullable_to_non_nullable
              as double,
      macroMatch: null == macroMatch
          ? _value.macroMatch
          : macroMatch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      microMatch: null == microMatch
          ? _value.microMatch
          : microMatch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      gaps: null == gaps
          ? _value.gaps
          : gaps // ignore: cast_nullable_to_non_nullable
              as List<NutritionGap>,
      excesses: null == excesses
          ? _value.excesses
          : excesses // ignore: cast_nullable_to_non_nullable
              as List<NutritionExcess>,
      recommendations: null == recommendations
          ? _value.recommendations
          : recommendations // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionBalanceAnalysisImplCopyWith<$Res>
    implements $NutritionBalanceAnalysisCopyWith<$Res> {
  factory _$$NutritionBalanceAnalysisImplCopyWith(
          _$NutritionBalanceAnalysisImpl value,
          $Res Function(_$NutritionBalanceAnalysisImpl) then) =
      __$$NutritionBalanceAnalysisImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double overallMatch,
      Map<String, dynamic> macroMatch,
      Map<String, dynamic> microMatch,
      List<NutritionGap> gaps,
      List<NutritionExcess> excesses,
      List<String> recommendations});
}

/// @nodoc
class __$$NutritionBalanceAnalysisImplCopyWithImpl<$Res>
    extends _$NutritionBalanceAnalysisCopyWithImpl<$Res,
        _$NutritionBalanceAnalysisImpl>
    implements _$$NutritionBalanceAnalysisImplCopyWith<$Res> {
  __$$NutritionBalanceAnalysisImplCopyWithImpl(
      _$NutritionBalanceAnalysisImpl _value,
      $Res Function(_$NutritionBalanceAnalysisImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionBalanceAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? overallMatch = null,
    Object? macroMatch = null,
    Object? microMatch = null,
    Object? gaps = null,
    Object? excesses = null,
    Object? recommendations = null,
  }) {
    return _then(_$NutritionBalanceAnalysisImpl(
      overallMatch: null == overallMatch
          ? _value.overallMatch
          : overallMatch // ignore: cast_nullable_to_non_nullable
              as double,
      macroMatch: null == macroMatch
          ? _value._macroMatch
          : macroMatch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      microMatch: null == microMatch
          ? _value._microMatch
          : microMatch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      gaps: null == gaps
          ? _value._gaps
          : gaps // ignore: cast_nullable_to_non_nullable
              as List<NutritionGap>,
      excesses: null == excesses
          ? _value._excesses
          : excesses // ignore: cast_nullable_to_non_nullable
              as List<NutritionExcess>,
      recommendations: null == recommendations
          ? _value._recommendations
          : recommendations // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionBalanceAnalysisImpl implements _NutritionBalanceAnalysis {
  const _$NutritionBalanceAnalysisImpl(
      {required this.overallMatch,
      required final Map<String, dynamic> macroMatch,
      required final Map<String, dynamic> microMatch,
      final List<NutritionGap> gaps = const [],
      final List<NutritionExcess> excesses = const [],
      final List<String> recommendations = const []})
      : _macroMatch = macroMatch,
        _microMatch = microMatch,
        _gaps = gaps,
        _excesses = excesses,
        _recommendations = recommendations;

  factory _$NutritionBalanceAnalysisImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionBalanceAnalysisImplFromJson(json);

  @override
  final double overallMatch;
  final Map<String, dynamic> _macroMatch;
  @override
  Map<String, dynamic> get macroMatch {
    if (_macroMatch is EqualUnmodifiableMapView) return _macroMatch;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_macroMatch);
  }

  final Map<String, dynamic> _microMatch;
  @override
  Map<String, dynamic> get microMatch {
    if (_microMatch is EqualUnmodifiableMapView) return _microMatch;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_microMatch);
  }

  final List<NutritionGap> _gaps;
  @override
  @JsonKey()
  List<NutritionGap> get gaps {
    if (_gaps is EqualUnmodifiableListView) return _gaps;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_gaps);
  }

  final List<NutritionExcess> _excesses;
  @override
  @JsonKey()
  List<NutritionExcess> get excesses {
    if (_excesses is EqualUnmodifiableListView) return _excesses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_excesses);
  }

  final List<String> _recommendations;
  @override
  @JsonKey()
  List<String> get recommendations {
    if (_recommendations is EqualUnmodifiableListView) return _recommendations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_recommendations);
  }

  @override
  String toString() {
    return 'NutritionBalanceAnalysis(overallMatch: $overallMatch, macroMatch: $macroMatch, microMatch: $microMatch, gaps: $gaps, excesses: $excesses, recommendations: $recommendations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionBalanceAnalysisImpl &&
            (identical(other.overallMatch, overallMatch) ||
                other.overallMatch == overallMatch) &&
            const DeepCollectionEquality()
                .equals(other._macroMatch, _macroMatch) &&
            const DeepCollectionEquality()
                .equals(other._microMatch, _microMatch) &&
            const DeepCollectionEquality().equals(other._gaps, _gaps) &&
            const DeepCollectionEquality().equals(other._excesses, _excesses) &&
            const DeepCollectionEquality()
                .equals(other._recommendations, _recommendations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      overallMatch,
      const DeepCollectionEquality().hash(_macroMatch),
      const DeepCollectionEquality().hash(_microMatch),
      const DeepCollectionEquality().hash(_gaps),
      const DeepCollectionEquality().hash(_excesses),
      const DeepCollectionEquality().hash(_recommendations));

  /// Create a copy of NutritionBalanceAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionBalanceAnalysisImplCopyWith<_$NutritionBalanceAnalysisImpl>
      get copyWith => __$$NutritionBalanceAnalysisImplCopyWithImpl<
          _$NutritionBalanceAnalysisImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionBalanceAnalysis value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionBalanceAnalysis value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionBalanceAnalysis value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionBalanceAnalysisImplToJson(
      this,
    );
  }
}

abstract class _NutritionBalanceAnalysis implements NutritionBalanceAnalysis {
  const factory _NutritionBalanceAnalysis(
      {required final double overallMatch,
      required final Map<String, dynamic> macroMatch,
      required final Map<String, dynamic> microMatch,
      final List<NutritionGap> gaps,
      final List<NutritionExcess> excesses,
      final List<String> recommendations}) = _$NutritionBalanceAnalysisImpl;

  factory _NutritionBalanceAnalysis.fromJson(Map<String, dynamic> json) =
      _$NutritionBalanceAnalysisImpl.fromJson;

  @override
  double get overallMatch;
  @override
  Map<String, dynamic> get macroMatch;
  @override
  Map<String, dynamic> get microMatch;
  @override
  List<NutritionGap> get gaps;
  @override
  List<NutritionExcess> get excesses;
  @override
  List<String> get recommendations;

  /// Create a copy of NutritionBalanceAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionBalanceAnalysisImplCopyWith<_$NutritionBalanceAnalysisImpl>
      get copyWith => throw _privateConstructorUsedError;
}

NutritionGap _$NutritionGapFromJson(Map<String, dynamic> json) {
  return _NutritionGap.fromJson(json);
}

/// @nodoc
mixin _$NutritionGap {
  String get element => throw _privateConstructorUsedError;
  double get currentAmount => throw _privateConstructorUsedError;
  double get targetAmount => throw _privateConstructorUsedError;
  double get gapAmount => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  String? get severity => throw _privateConstructorUsedError;
  List<String> get recommendedSources => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionGap value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionGap value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionGap value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionGap to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionGap
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionGapCopyWith<NutritionGap> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionGapCopyWith<$Res> {
  factory $NutritionGapCopyWith(
          NutritionGap value, $Res Function(NutritionGap) then) =
      _$NutritionGapCopyWithImpl<$Res, NutritionGap>;
  @useResult
  $Res call(
      {String element,
      double currentAmount,
      double targetAmount,
      double gapAmount,
      String unit,
      String? severity,
      List<String> recommendedSources});
}

/// @nodoc
class _$NutritionGapCopyWithImpl<$Res, $Val extends NutritionGap>
    implements $NutritionGapCopyWith<$Res> {
  _$NutritionGapCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionGap
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? element = null,
    Object? currentAmount = null,
    Object? targetAmount = null,
    Object? gapAmount = null,
    Object? unit = null,
    Object? severity = freezed,
    Object? recommendedSources = null,
  }) {
    return _then(_value.copyWith(
      element: null == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String,
      currentAmount: null == currentAmount
          ? _value.currentAmount
          : currentAmount // ignore: cast_nullable_to_non_nullable
              as double,
      targetAmount: null == targetAmount
          ? _value.targetAmount
          : targetAmount // ignore: cast_nullable_to_non_nullable
              as double,
      gapAmount: null == gapAmount
          ? _value.gapAmount
          : gapAmount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      severity: freezed == severity
          ? _value.severity
          : severity // ignore: cast_nullable_to_non_nullable
              as String?,
      recommendedSources: null == recommendedSources
          ? _value.recommendedSources
          : recommendedSources // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionGapImplCopyWith<$Res>
    implements $NutritionGapCopyWith<$Res> {
  factory _$$NutritionGapImplCopyWith(
          _$NutritionGapImpl value, $Res Function(_$NutritionGapImpl) then) =
      __$$NutritionGapImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String element,
      double currentAmount,
      double targetAmount,
      double gapAmount,
      String unit,
      String? severity,
      List<String> recommendedSources});
}

/// @nodoc
class __$$NutritionGapImplCopyWithImpl<$Res>
    extends _$NutritionGapCopyWithImpl<$Res, _$NutritionGapImpl>
    implements _$$NutritionGapImplCopyWith<$Res> {
  __$$NutritionGapImplCopyWithImpl(
      _$NutritionGapImpl _value, $Res Function(_$NutritionGapImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionGap
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? element = null,
    Object? currentAmount = null,
    Object? targetAmount = null,
    Object? gapAmount = null,
    Object? unit = null,
    Object? severity = freezed,
    Object? recommendedSources = null,
  }) {
    return _then(_$NutritionGapImpl(
      element: null == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String,
      currentAmount: null == currentAmount
          ? _value.currentAmount
          : currentAmount // ignore: cast_nullable_to_non_nullable
              as double,
      targetAmount: null == targetAmount
          ? _value.targetAmount
          : targetAmount // ignore: cast_nullable_to_non_nullable
              as double,
      gapAmount: null == gapAmount
          ? _value.gapAmount
          : gapAmount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      severity: freezed == severity
          ? _value.severity
          : severity // ignore: cast_nullable_to_non_nullable
              as String?,
      recommendedSources: null == recommendedSources
          ? _value._recommendedSources
          : recommendedSources // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionGapImpl implements _NutritionGap {
  const _$NutritionGapImpl(
      {required this.element,
      required this.currentAmount,
      required this.targetAmount,
      required this.gapAmount,
      required this.unit,
      this.severity,
      final List<String> recommendedSources = const []})
      : _recommendedSources = recommendedSources;

  factory _$NutritionGapImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionGapImplFromJson(json);

  @override
  final String element;
  @override
  final double currentAmount;
  @override
  final double targetAmount;
  @override
  final double gapAmount;
  @override
  final String unit;
  @override
  final String? severity;
  final List<String> _recommendedSources;
  @override
  @JsonKey()
  List<String> get recommendedSources {
    if (_recommendedSources is EqualUnmodifiableListView)
      return _recommendedSources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_recommendedSources);
  }

  @override
  String toString() {
    return 'NutritionGap(element: $element, currentAmount: $currentAmount, targetAmount: $targetAmount, gapAmount: $gapAmount, unit: $unit, severity: $severity, recommendedSources: $recommendedSources)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionGapImpl &&
            (identical(other.element, element) || other.element == element) &&
            (identical(other.currentAmount, currentAmount) ||
                other.currentAmount == currentAmount) &&
            (identical(other.targetAmount, targetAmount) ||
                other.targetAmount == targetAmount) &&
            (identical(other.gapAmount, gapAmount) ||
                other.gapAmount == gapAmount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.severity, severity) ||
                other.severity == severity) &&
            const DeepCollectionEquality()
                .equals(other._recommendedSources, _recommendedSources));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      element,
      currentAmount,
      targetAmount,
      gapAmount,
      unit,
      severity,
      const DeepCollectionEquality().hash(_recommendedSources));

  /// Create a copy of NutritionGap
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionGapImplCopyWith<_$NutritionGapImpl> get copyWith =>
      __$$NutritionGapImplCopyWithImpl<_$NutritionGapImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionGap value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionGap value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionGap value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionGapImplToJson(
      this,
    );
  }
}

abstract class _NutritionGap implements NutritionGap {
  const factory _NutritionGap(
      {required final String element,
      required final double currentAmount,
      required final double targetAmount,
      required final double gapAmount,
      required final String unit,
      final String? severity,
      final List<String> recommendedSources}) = _$NutritionGapImpl;

  factory _NutritionGap.fromJson(Map<String, dynamic> json) =
      _$NutritionGapImpl.fromJson;

  @override
  String get element;
  @override
  double get currentAmount;
  @override
  double get targetAmount;
  @override
  double get gapAmount;
  @override
  String get unit;
  @override
  String? get severity;
  @override
  List<String> get recommendedSources;

  /// Create a copy of NutritionGap
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionGapImplCopyWith<_$NutritionGapImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NutritionExcess _$NutritionExcessFromJson(Map<String, dynamic> json) {
  return _NutritionExcess.fromJson(json);
}

/// @nodoc
mixin _$NutritionExcess {
  String get element => throw _privateConstructorUsedError;
  double get currentAmount => throw _privateConstructorUsedError;
  double get targetAmount => throw _privateConstructorUsedError;
  double get excessAmount => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  String? get riskLevel => throw _privateConstructorUsedError;
  List<String> get reductionSuggestions => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionExcess value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionExcess value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionExcess value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionExcess to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionExcess
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionExcessCopyWith<NutritionExcess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionExcessCopyWith<$Res> {
  factory $NutritionExcessCopyWith(
          NutritionExcess value, $Res Function(NutritionExcess) then) =
      _$NutritionExcessCopyWithImpl<$Res, NutritionExcess>;
  @useResult
  $Res call(
      {String element,
      double currentAmount,
      double targetAmount,
      double excessAmount,
      String unit,
      String? riskLevel,
      List<String> reductionSuggestions});
}

/// @nodoc
class _$NutritionExcessCopyWithImpl<$Res, $Val extends NutritionExcess>
    implements $NutritionExcessCopyWith<$Res> {
  _$NutritionExcessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionExcess
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? element = null,
    Object? currentAmount = null,
    Object? targetAmount = null,
    Object? excessAmount = null,
    Object? unit = null,
    Object? riskLevel = freezed,
    Object? reductionSuggestions = null,
  }) {
    return _then(_value.copyWith(
      element: null == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String,
      currentAmount: null == currentAmount
          ? _value.currentAmount
          : currentAmount // ignore: cast_nullable_to_non_nullable
              as double,
      targetAmount: null == targetAmount
          ? _value.targetAmount
          : targetAmount // ignore: cast_nullable_to_non_nullable
              as double,
      excessAmount: null == excessAmount
          ? _value.excessAmount
          : excessAmount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      riskLevel: freezed == riskLevel
          ? _value.riskLevel
          : riskLevel // ignore: cast_nullable_to_non_nullable
              as String?,
      reductionSuggestions: null == reductionSuggestions
          ? _value.reductionSuggestions
          : reductionSuggestions // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionExcessImplCopyWith<$Res>
    implements $NutritionExcessCopyWith<$Res> {
  factory _$$NutritionExcessImplCopyWith(_$NutritionExcessImpl value,
          $Res Function(_$NutritionExcessImpl) then) =
      __$$NutritionExcessImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String element,
      double currentAmount,
      double targetAmount,
      double excessAmount,
      String unit,
      String? riskLevel,
      List<String> reductionSuggestions});
}

/// @nodoc
class __$$NutritionExcessImplCopyWithImpl<$Res>
    extends _$NutritionExcessCopyWithImpl<$Res, _$NutritionExcessImpl>
    implements _$$NutritionExcessImplCopyWith<$Res> {
  __$$NutritionExcessImplCopyWithImpl(
      _$NutritionExcessImpl _value, $Res Function(_$NutritionExcessImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionExcess
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? element = null,
    Object? currentAmount = null,
    Object? targetAmount = null,
    Object? excessAmount = null,
    Object? unit = null,
    Object? riskLevel = freezed,
    Object? reductionSuggestions = null,
  }) {
    return _then(_$NutritionExcessImpl(
      element: null == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String,
      currentAmount: null == currentAmount
          ? _value.currentAmount
          : currentAmount // ignore: cast_nullable_to_non_nullable
              as double,
      targetAmount: null == targetAmount
          ? _value.targetAmount
          : targetAmount // ignore: cast_nullable_to_non_nullable
              as double,
      excessAmount: null == excessAmount
          ? _value.excessAmount
          : excessAmount // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      riskLevel: freezed == riskLevel
          ? _value.riskLevel
          : riskLevel // ignore: cast_nullable_to_non_nullable
              as String?,
      reductionSuggestions: null == reductionSuggestions
          ? _value._reductionSuggestions
          : reductionSuggestions // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionExcessImpl implements _NutritionExcess {
  const _$NutritionExcessImpl(
      {required this.element,
      required this.currentAmount,
      required this.targetAmount,
      required this.excessAmount,
      required this.unit,
      this.riskLevel,
      final List<String> reductionSuggestions = const []})
      : _reductionSuggestions = reductionSuggestions;

  factory _$NutritionExcessImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionExcessImplFromJson(json);

  @override
  final String element;
  @override
  final double currentAmount;
  @override
  final double targetAmount;
  @override
  final double excessAmount;
  @override
  final String unit;
  @override
  final String? riskLevel;
  final List<String> _reductionSuggestions;
  @override
  @JsonKey()
  List<String> get reductionSuggestions {
    if (_reductionSuggestions is EqualUnmodifiableListView)
      return _reductionSuggestions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reductionSuggestions);
  }

  @override
  String toString() {
    return 'NutritionExcess(element: $element, currentAmount: $currentAmount, targetAmount: $targetAmount, excessAmount: $excessAmount, unit: $unit, riskLevel: $riskLevel, reductionSuggestions: $reductionSuggestions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionExcessImpl &&
            (identical(other.element, element) || other.element == element) &&
            (identical(other.currentAmount, currentAmount) ||
                other.currentAmount == currentAmount) &&
            (identical(other.targetAmount, targetAmount) ||
                other.targetAmount == targetAmount) &&
            (identical(other.excessAmount, excessAmount) ||
                other.excessAmount == excessAmount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.riskLevel, riskLevel) ||
                other.riskLevel == riskLevel) &&
            const DeepCollectionEquality()
                .equals(other._reductionSuggestions, _reductionSuggestions));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      element,
      currentAmount,
      targetAmount,
      excessAmount,
      unit,
      riskLevel,
      const DeepCollectionEquality().hash(_reductionSuggestions));

  /// Create a copy of NutritionExcess
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionExcessImplCopyWith<_$NutritionExcessImpl> get copyWith =>
      __$$NutritionExcessImplCopyWithImpl<_$NutritionExcessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionExcess value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionExcess value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionExcess value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionExcessImplToJson(
      this,
    );
  }
}

abstract class _NutritionExcess implements NutritionExcess {
  const factory _NutritionExcess(
      {required final String element,
      required final double currentAmount,
      required final double targetAmount,
      required final double excessAmount,
      required final String unit,
      final String? riskLevel,
      final List<String> reductionSuggestions}) = _$NutritionExcessImpl;

  factory _NutritionExcess.fromJson(Map<String, dynamic> json) =
      _$NutritionExcessImpl.fromJson;

  @override
  String get element;
  @override
  double get currentAmount;
  @override
  double get targetAmount;
  @override
  double get excessAmount;
  @override
  String get unit;
  @override
  String? get riskLevel;
  @override
  List<String> get reductionSuggestions;

  /// Create a copy of NutritionExcess
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionExcessImplCopyWith<_$NutritionExcessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientRecommendation _$IngredientRecommendationFromJson(
    Map<String, dynamic> json) {
  return _IngredientRecommendation.fromJson(json);
}

/// @nodoc
mixin _$IngredientRecommendation {
  String get nutrient => throw _privateConstructorUsedError;
  double get gap => throw _privateConstructorUsedError;
  String get unit => throw _privateConstructorUsedError;
  List<RecommendedIngredient> get recommendedIngredients =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_IngredientRecommendation value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_IngredientRecommendation value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_IngredientRecommendation value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this IngredientRecommendation to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IngredientRecommendation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IngredientRecommendationCopyWith<IngredientRecommendation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientRecommendationCopyWith<$Res> {
  factory $IngredientRecommendationCopyWith(IngredientRecommendation value,
          $Res Function(IngredientRecommendation) then) =
      _$IngredientRecommendationCopyWithImpl<$Res, IngredientRecommendation>;
  @useResult
  $Res call(
      {String nutrient,
      double gap,
      String unit,
      List<RecommendedIngredient> recommendedIngredients});
}

/// @nodoc
class _$IngredientRecommendationCopyWithImpl<$Res,
        $Val extends IngredientRecommendation>
    implements $IngredientRecommendationCopyWith<$Res> {
  _$IngredientRecommendationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IngredientRecommendation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nutrient = null,
    Object? gap = null,
    Object? unit = null,
    Object? recommendedIngredients = null,
  }) {
    return _then(_value.copyWith(
      nutrient: null == nutrient
          ? _value.nutrient
          : nutrient // ignore: cast_nullable_to_non_nullable
              as String,
      gap: null == gap
          ? _value.gap
          : gap // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      recommendedIngredients: null == recommendedIngredients
          ? _value.recommendedIngredients
          : recommendedIngredients // ignore: cast_nullable_to_non_nullable
              as List<RecommendedIngredient>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IngredientRecommendationImplCopyWith<$Res>
    implements $IngredientRecommendationCopyWith<$Res> {
  factory _$$IngredientRecommendationImplCopyWith(
          _$IngredientRecommendationImpl value,
          $Res Function(_$IngredientRecommendationImpl) then) =
      __$$IngredientRecommendationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String nutrient,
      double gap,
      String unit,
      List<RecommendedIngredient> recommendedIngredients});
}

/// @nodoc
class __$$IngredientRecommendationImplCopyWithImpl<$Res>
    extends _$IngredientRecommendationCopyWithImpl<$Res,
        _$IngredientRecommendationImpl>
    implements _$$IngredientRecommendationImplCopyWith<$Res> {
  __$$IngredientRecommendationImplCopyWithImpl(
      _$IngredientRecommendationImpl _value,
      $Res Function(_$IngredientRecommendationImpl) _then)
      : super(_value, _then);

  /// Create a copy of IngredientRecommendation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nutrient = null,
    Object? gap = null,
    Object? unit = null,
    Object? recommendedIngredients = null,
  }) {
    return _then(_$IngredientRecommendationImpl(
      nutrient: null == nutrient
          ? _value.nutrient
          : nutrient // ignore: cast_nullable_to_non_nullable
              as String,
      gap: null == gap
          ? _value.gap
          : gap // ignore: cast_nullable_to_non_nullable
              as double,
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      recommendedIngredients: null == recommendedIngredients
          ? _value._recommendedIngredients
          : recommendedIngredients // ignore: cast_nullable_to_non_nullable
              as List<RecommendedIngredient>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IngredientRecommendationImpl implements _IngredientRecommendation {
  const _$IngredientRecommendationImpl(
      {required this.nutrient,
      required this.gap,
      required this.unit,
      final List<RecommendedIngredient> recommendedIngredients = const []})
      : _recommendedIngredients = recommendedIngredients;

  factory _$IngredientRecommendationImpl.fromJson(Map<String, dynamic> json) =>
      _$$IngredientRecommendationImplFromJson(json);

  @override
  final String nutrient;
  @override
  final double gap;
  @override
  final String unit;
  final List<RecommendedIngredient> _recommendedIngredients;
  @override
  @JsonKey()
  List<RecommendedIngredient> get recommendedIngredients {
    if (_recommendedIngredients is EqualUnmodifiableListView)
      return _recommendedIngredients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_recommendedIngredients);
  }

  @override
  String toString() {
    return 'IngredientRecommendation(nutrient: $nutrient, gap: $gap, unit: $unit, recommendedIngredients: $recommendedIngredients)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IngredientRecommendationImpl &&
            (identical(other.nutrient, nutrient) ||
                other.nutrient == nutrient) &&
            (identical(other.gap, gap) || other.gap == gap) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            const DeepCollectionEquality().equals(
                other._recommendedIngredients, _recommendedIngredients));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, nutrient, gap, unit,
      const DeepCollectionEquality().hash(_recommendedIngredients));

  /// Create a copy of IngredientRecommendation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IngredientRecommendationImplCopyWith<_$IngredientRecommendationImpl>
      get copyWith => __$$IngredientRecommendationImplCopyWithImpl<
          _$IngredientRecommendationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_IngredientRecommendation value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_IngredientRecommendation value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_IngredientRecommendation value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IngredientRecommendationImplToJson(
      this,
    );
  }
}

abstract class _IngredientRecommendation implements IngredientRecommendation {
  const factory _IngredientRecommendation(
          {required final String nutrient,
          required final double gap,
          required final String unit,
          final List<RecommendedIngredient> recommendedIngredients}) =
      _$IngredientRecommendationImpl;

  factory _IngredientRecommendation.fromJson(Map<String, dynamic> json) =
      _$IngredientRecommendationImpl.fromJson;

  @override
  String get nutrient;
  @override
  double get gap;
  @override
  String get unit;
  @override
  List<RecommendedIngredient> get recommendedIngredients;

  /// Create a copy of IngredientRecommendation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IngredientRecommendationImplCopyWith<_$IngredientRecommendationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RecommendedIngredient _$RecommendedIngredientFromJson(
    Map<String, dynamic> json) {
  return _RecommendedIngredient.fromJson(json);
}

/// @nodoc
mixin _$RecommendedIngredient {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get category => throw _privateConstructorUsedError;
  double get nutrientContent => throw _privateConstructorUsedError;
  String get nutritionDensity => throw _privateConstructorUsedError;
  ServingSize get servingSize => throw _privateConstructorUsedError;
  double get estimatedServing => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RecommendedIngredient value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RecommendedIngredient value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RecommendedIngredient value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this RecommendedIngredient to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of RecommendedIngredient
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RecommendedIngredientCopyWith<RecommendedIngredient> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecommendedIngredientCopyWith<$Res> {
  factory $RecommendedIngredientCopyWith(RecommendedIngredient value,
          $Res Function(RecommendedIngredient) then) =
      _$RecommendedIngredientCopyWithImpl<$Res, RecommendedIngredient>;
  @useResult
  $Res call(
      {String id,
      String name,
      String category,
      double nutrientContent,
      String nutritionDensity,
      ServingSize servingSize,
      double estimatedServing});

  $ServingSizeCopyWith<$Res> get servingSize;
}

/// @nodoc
class _$RecommendedIngredientCopyWithImpl<$Res,
        $Val extends RecommendedIngredient>
    implements $RecommendedIngredientCopyWith<$Res> {
  _$RecommendedIngredientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RecommendedIngredient
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? category = null,
    Object? nutrientContent = null,
    Object? nutritionDensity = null,
    Object? servingSize = null,
    Object? estimatedServing = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      nutrientContent: null == nutrientContent
          ? _value.nutrientContent
          : nutrientContent // ignore: cast_nullable_to_non_nullable
              as double,
      nutritionDensity: null == nutritionDensity
          ? _value.nutritionDensity
          : nutritionDensity // ignore: cast_nullable_to_non_nullable
              as String,
      servingSize: null == servingSize
          ? _value.servingSize
          : servingSize // ignore: cast_nullable_to_non_nullable
              as ServingSize,
      estimatedServing: null == estimatedServing
          ? _value.estimatedServing
          : estimatedServing // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }

  /// Create a copy of RecommendedIngredient
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ServingSizeCopyWith<$Res> get servingSize {
    return $ServingSizeCopyWith<$Res>(_value.servingSize, (value) {
      return _then(_value.copyWith(servingSize: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RecommendedIngredientImplCopyWith<$Res>
    implements $RecommendedIngredientCopyWith<$Res> {
  factory _$$RecommendedIngredientImplCopyWith(
          _$RecommendedIngredientImpl value,
          $Res Function(_$RecommendedIngredientImpl) then) =
      __$$RecommendedIngredientImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String category,
      double nutrientContent,
      String nutritionDensity,
      ServingSize servingSize,
      double estimatedServing});

  @override
  $ServingSizeCopyWith<$Res> get servingSize;
}

/// @nodoc
class __$$RecommendedIngredientImplCopyWithImpl<$Res>
    extends _$RecommendedIngredientCopyWithImpl<$Res,
        _$RecommendedIngredientImpl>
    implements _$$RecommendedIngredientImplCopyWith<$Res> {
  __$$RecommendedIngredientImplCopyWithImpl(_$RecommendedIngredientImpl _value,
      $Res Function(_$RecommendedIngredientImpl) _then)
      : super(_value, _then);

  /// Create a copy of RecommendedIngredient
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? category = null,
    Object? nutrientContent = null,
    Object? nutritionDensity = null,
    Object? servingSize = null,
    Object? estimatedServing = null,
  }) {
    return _then(_$RecommendedIngredientImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      nutrientContent: null == nutrientContent
          ? _value.nutrientContent
          : nutrientContent // ignore: cast_nullable_to_non_nullable
              as double,
      nutritionDensity: null == nutritionDensity
          ? _value.nutritionDensity
          : nutritionDensity // ignore: cast_nullable_to_non_nullable
              as String,
      servingSize: null == servingSize
          ? _value.servingSize
          : servingSize // ignore: cast_nullable_to_non_nullable
              as ServingSize,
      estimatedServing: null == estimatedServing
          ? _value.estimatedServing
          : estimatedServing // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RecommendedIngredientImpl implements _RecommendedIngredient {
  const _$RecommendedIngredientImpl(
      {required this.id,
      required this.name,
      required this.category,
      required this.nutrientContent,
      required this.nutritionDensity,
      required this.servingSize,
      required this.estimatedServing});

  factory _$RecommendedIngredientImpl.fromJson(Map<String, dynamic> json) =>
      _$$RecommendedIngredientImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String category;
  @override
  final double nutrientContent;
  @override
  final String nutritionDensity;
  @override
  final ServingSize servingSize;
  @override
  final double estimatedServing;

  @override
  String toString() {
    return 'RecommendedIngredient(id: $id, name: $name, category: $category, nutrientContent: $nutrientContent, nutritionDensity: $nutritionDensity, servingSize: $servingSize, estimatedServing: $estimatedServing)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecommendedIngredientImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.nutrientContent, nutrientContent) ||
                other.nutrientContent == nutrientContent) &&
            (identical(other.nutritionDensity, nutritionDensity) ||
                other.nutritionDensity == nutritionDensity) &&
            (identical(other.servingSize, servingSize) ||
                other.servingSize == servingSize) &&
            (identical(other.estimatedServing, estimatedServing) ||
                other.estimatedServing == estimatedServing));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, category,
      nutrientContent, nutritionDensity, servingSize, estimatedServing);

  /// Create a copy of RecommendedIngredient
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RecommendedIngredientImplCopyWith<_$RecommendedIngredientImpl>
      get copyWith => __$$RecommendedIngredientImplCopyWithImpl<
          _$RecommendedIngredientImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RecommendedIngredient value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RecommendedIngredient value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RecommendedIngredient value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RecommendedIngredientImplToJson(
      this,
    );
  }
}

abstract class _RecommendedIngredient implements RecommendedIngredient {
  const factory _RecommendedIngredient(
      {required final String id,
      required final String name,
      required final String category,
      required final double nutrientContent,
      required final String nutritionDensity,
      required final ServingSize servingSize,
      required final double estimatedServing}) = _$RecommendedIngredientImpl;

  factory _RecommendedIngredient.fromJson(Map<String, dynamic> json) =
      _$RecommendedIngredientImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get category;
  @override
  double get nutrientContent;
  @override
  String get nutritionDensity;
  @override
  ServingSize get servingSize;
  @override
  double get estimatedServing;

  /// Create a copy of RecommendedIngredient
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RecommendedIngredientImplCopyWith<_$RecommendedIngredientImpl>
      get copyWith => throw _privateConstructorUsedError;
}

NutritionScore _$NutritionScoreFromJson(Map<String, dynamic> json) {
  return _NutritionScore.fromJson(json);
}

/// @nodoc
mixin _$NutritionScore {
  double get overall => throw _privateConstructorUsedError;
  double get balance => throw _privateConstructorUsedError;
  double get adequacy => throw _privateConstructorUsedError;
  double get moderation => throw _privateConstructorUsedError;
  double get variety => throw _privateConstructorUsedError;
  Map<String, dynamic> get details => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionScore value) $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionScore value)? $default,
  ) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionScore value)? $default, {
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this NutritionScore to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NutritionScore
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NutritionScoreCopyWith<NutritionScore> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NutritionScoreCopyWith<$Res> {
  factory $NutritionScoreCopyWith(
          NutritionScore value, $Res Function(NutritionScore) then) =
      _$NutritionScoreCopyWithImpl<$Res, NutritionScore>;
  @useResult
  $Res call(
      {double overall,
      double balance,
      double adequacy,
      double moderation,
      double variety,
      Map<String, dynamic> details});
}

/// @nodoc
class _$NutritionScoreCopyWithImpl<$Res, $Val extends NutritionScore>
    implements $NutritionScoreCopyWith<$Res> {
  _$NutritionScoreCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NutritionScore
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? overall = null,
    Object? balance = null,
    Object? adequacy = null,
    Object? moderation = null,
    Object? variety = null,
    Object? details = null,
  }) {
    return _then(_value.copyWith(
      overall: null == overall
          ? _value.overall
          : overall // ignore: cast_nullable_to_non_nullable
              as double,
      balance: null == balance
          ? _value.balance
          : balance // ignore: cast_nullable_to_non_nullable
              as double,
      adequacy: null == adequacy
          ? _value.adequacy
          : adequacy // ignore: cast_nullable_to_non_nullable
              as double,
      moderation: null == moderation
          ? _value.moderation
          : moderation // ignore: cast_nullable_to_non_nullable
              as double,
      variety: null == variety
          ? _value.variety
          : variety // ignore: cast_nullable_to_non_nullable
              as double,
      details: null == details
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NutritionScoreImplCopyWith<$Res>
    implements $NutritionScoreCopyWith<$Res> {
  factory _$$NutritionScoreImplCopyWith(_$NutritionScoreImpl value,
          $Res Function(_$NutritionScoreImpl) then) =
      __$$NutritionScoreImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double overall,
      double balance,
      double adequacy,
      double moderation,
      double variety,
      Map<String, dynamic> details});
}

/// @nodoc
class __$$NutritionScoreImplCopyWithImpl<$Res>
    extends _$NutritionScoreCopyWithImpl<$Res, _$NutritionScoreImpl>
    implements _$$NutritionScoreImplCopyWith<$Res> {
  __$$NutritionScoreImplCopyWithImpl(
      _$NutritionScoreImpl _value, $Res Function(_$NutritionScoreImpl) _then)
      : super(_value, _then);

  /// Create a copy of NutritionScore
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? overall = null,
    Object? balance = null,
    Object? adequacy = null,
    Object? moderation = null,
    Object? variety = null,
    Object? details = null,
  }) {
    return _then(_$NutritionScoreImpl(
      overall: null == overall
          ? _value.overall
          : overall // ignore: cast_nullable_to_non_nullable
              as double,
      balance: null == balance
          ? _value.balance
          : balance // ignore: cast_nullable_to_non_nullable
              as double,
      adequacy: null == adequacy
          ? _value.adequacy
          : adequacy // ignore: cast_nullable_to_non_nullable
              as double,
      moderation: null == moderation
          ? _value.moderation
          : moderation // ignore: cast_nullable_to_non_nullable
              as double,
      variety: null == variety
          ? _value.variety
          : variety // ignore: cast_nullable_to_non_nullable
              as double,
      details: null == details
          ? _value._details
          : details // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NutritionScoreImpl implements _NutritionScore {
  const _$NutritionScoreImpl(
      {required this.overall,
      required this.balance,
      required this.adequacy,
      required this.moderation,
      required this.variety,
      required final Map<String, dynamic> details})
      : _details = details;

  factory _$NutritionScoreImpl.fromJson(Map<String, dynamic> json) =>
      _$$NutritionScoreImplFromJson(json);

  @override
  final double overall;
  @override
  final double balance;
  @override
  final double adequacy;
  @override
  final double moderation;
  @override
  final double variety;
  final Map<String, dynamic> _details;
  @override
  Map<String, dynamic> get details {
    if (_details is EqualUnmodifiableMapView) return _details;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_details);
  }

  @override
  String toString() {
    return 'NutritionScore(overall: $overall, balance: $balance, adequacy: $adequacy, moderation: $moderation, variety: $variety, details: $details)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NutritionScoreImpl &&
            (identical(other.overall, overall) || other.overall == overall) &&
            (identical(other.balance, balance) || other.balance == balance) &&
            (identical(other.adequacy, adequacy) ||
                other.adequacy == adequacy) &&
            (identical(other.moderation, moderation) ||
                other.moderation == moderation) &&
            (identical(other.variety, variety) || other.variety == variety) &&
            const DeepCollectionEquality().equals(other._details, _details));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, overall, balance, adequacy,
      moderation, variety, const DeepCollectionEquality().hash(_details));

  /// Create a copy of NutritionScore
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NutritionScoreImplCopyWith<_$NutritionScoreImpl> get copyWith =>
      __$$NutritionScoreImplCopyWithImpl<_$NutritionScoreImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NutritionScore value) $default,
  ) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NutritionScore value)? $default,
  ) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NutritionScore value)? $default, {
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NutritionScoreImplToJson(
      this,
    );
  }
}

abstract class _NutritionScore implements NutritionScore {
  const factory _NutritionScore(
      {required final double overall,
      required final double balance,
      required final double adequacy,
      required final double moderation,
      required final double variety,
      required final Map<String, dynamic> details}) = _$NutritionScoreImpl;

  factory _NutritionScore.fromJson(Map<String, dynamic> json) =
      _$NutritionScoreImpl.fromJson;

  @override
  double get overall;
  @override
  double get balance;
  @override
  double get adequacy;
  @override
  double get moderation;
  @override
  double get variety;
  @override
  Map<String, dynamic> get details;

  /// Create a copy of NutritionScore
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NutritionScoreImplCopyWith<_$NutritionScoreImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
